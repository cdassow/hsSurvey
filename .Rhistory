F.P.P <- D(F.P, "P")
#get sequence of ks, find equilibira for ks and evaluate jacobian to get eigenvalues
k <- 10
R <- 50
a <- 0.005
HPeigs <- sapply(k, function(ki) {
k <- ki
P <- k*(R^(1/k) - 1)/a
H <- P * R/(R-1)
jac <- matrix( c(eval(F.H.H), eval(F.H.P), eval(F.P.H), eval(F.P.P)),
nrow=2, byrow=TRUE )
eigen(jac)[["values"]]
} )
#plot eignvalue with the greatest value
modmaxs <- apply( HPeigs, 2, function(lambdas) {i <- which.max(Mod(lambdas))
sign(Re(lambdas[i])) * Mod(lambdas[i]) })
plot(R, modmaxs, type='l', ylab=quote("Stability "*(lambda[1])), main ="Stability vs. R" )
abline(h=-1, lty=3)
abline(h=-1, lty=3)
#get sequence of ks, find equilibira for ks and evaluate jacobian to get eigenvalues
k <- 10
R <- 1
a <- 0.005
HPeigs <- sapply(k, function(ki) {
k <- ki
P <- k*(R^(1/k) - 1)/a
H <- P * R/(R-1)
jac <- matrix( c(eval(F.H.H), eval(F.H.P), eval(F.P.H), eval(F.P.P)),
nrow=2, byrow=TRUE )
eigen(jac)[["values"]]
} )
#plot eignvalue with the greatest value
modmaxs <- apply( HPeigs, 2, function(lambdas) {i <- which.max(Mod(lambdas))
sign(Re(lambdas[i])) * Mod(lambdas[i]) })
plot(R, modmaxs, type='l', ylab=quote("Stability "*(lambda[1])), main ="Stability vs. R" )
abline(h=-1, lty=3)
#effects of a on stability
Does not have strong effects, lowers stability
#get sequence of ks, find equilibira for ks and evaluate jacobian to get eigenvalues
k <- 10
R <- 2
a <- 0.005
HPeigs <- sapply(k, function(ki) {
k <- ki
P <- k*(R^(1/k) - 1)/a
H <- P * R/(R-1)
jac <- matrix( c(eval(F.H.H), eval(F.H.P), eval(F.P.H), eval(F.P.P)),
nrow=2, byrow=TRUE )
eigen(jac)[["values"]]
} )
#plot eignvalue with the greatest value
modmaxs <- apply( HPeigs, 2, function(lambdas) {i <- which.max(Mod(lambdas))
sign(Re(lambdas[i])) * Mod(lambdas[i]) })
plot(R, modmaxs, type='l', ylab=quote("Stability "*(lambda[1])), main ="Stability vs. R" )
abline(h=-1, lty=3)
#plot eignvalue with the greatest value
modmaxs <- apply( HPeigs, 2, function(lambdas) {i <- which.max(Mod(lambdas))
sign(Re(lambdas[i])) * Mod(lambdas[i]) })
plot(R, modmaxs, type='l', ylab=quote("Stability "*(lambda[1])), main ="Stability vs. R" )
abline(h=-1, lty=3)
#get sequence of ks, find equilibira for ks and evaluate jacobian to get eigenvalues
k <- 10
R <- 3
a <- 0.005
HPeigs <- sapply(k, function(ki) {
k <- ki
P <- k*(R^(1/k) - 1)/a
H <- P * R/(R-1)
jac <- matrix( c(eval(F.H.H), eval(F.H.P), eval(F.P.H), eval(F.P.P)),
nrow=2, byrow=TRUE )
eigen(jac)[["values"]]
} )
#plot eignvalue with the greatest value
modmaxs <- apply( HPeigs, 2, function(lambdas) {i <- which.max(Mod(lambdas))
sign(Re(lambdas[i])) * Mod(lambdas[i]) })
plot(R, modmaxs, type='l', ylab=quote("Stability "*(lambda[1])), main ="Stability vs. R" )
abline(h=-1, lty=3)
#effects of a on stability
Does not have strong effects, lowers stability
#effects of R on stability
Increase in R decreases eignvalue
#SIR model (density dependent)
SIR <- function(t, y, p) {
{S <- y[1]; I <- y[2]; R <- y[3]}
with( as.list(p), {
dS.dt <- -B*I*S
dI.dt <- B*I*S - g*I
dR.dt <- g*I
return( list(c(dS.dt, dI.dt, dR.dt)) )
} )
}
#model outbreak example
N <- 10^4; I <- R <- 1; S <- N - I - R
parms <- c(B=.01, g=4)
months <- seq(0,3, by=0.01)
require(deSolve)
SIR.out <- data.frame( ode(c(S,I,R), months, SIR, parms) )
matplot(months, SIR.out[,-1], type='l', lty=1:3, col=1)
legend('right', c('R', 'I', 'S'), lty=3:1, col=3:1, bty='n')
#frequency dependent sir
SIRf <- function(t, y, p) {
{S <- y[1]; I <- y[2]; R <- y[3]; N<- S+I+R}
with( as.list(p), {
dS.dt <- -B*I*S/N
dI.dt <- B*I*S/N - g*I
dR.dt <- g*I
return( list(c(dS.dt, dI.dt, dR.dt)) )
} )
}
#transmission models
R <- 0; S <- I <- 1000; Ss <- Is <- seq(1, S, length=11); N <- S+I+R
betaD <- 0.1; betaF <- betaD*N
mat1 <- sapply(Is, function(i) betaD * i * Ss)
mat2 <- sapply(Is, function(i) betaF * i * Ss / (i + Ss + R) )
layout(matrix(1:2, nr=1))
persp(mat1, theta=20, phi=15, r=10, zlim=c(0,betaD*S*I),
main="Density Dependent",
xlab="I", ylab="S", zlab="Transmission Rate")
persp(mat2, theta=20, phi=15, r=10, zlim=c(0,betaF*S*I/N),
main="Frequency Dependent",
xlab="I", ylab="S", zlab="Transmission Rate")
S <- 4^(0:4)
I <- 1
parmsf <- c(B=1, g=0)
parmsd <- c(B=1/16, g=0)
Months <- seq(0, 8, by=0.1)
outd <- sapply(S, function(s) {out <- ode(c(s,I,R), Months, SIR, parmsd)
out[,3]/apply(out[,2:4], 1, sum) } )
outf <- sapply(S, function(s) {out <- ode(c(s,I,R), Months, SIRf, parmsf)
out[,3]/apply(out[,2:4], 1, sum) } )
#TR <- sapply(S, function(s) {R <- s/2; parmsf["B"]*s*I/(s+I+R)})
matplot(Months, outd, type='l', col=1, ylab="Prevalence (I/N)")
matplot(Months, outf, type='l', col=1, ylab="Prevalence (I/N)")
legend('bottomright', legend=S, lty=1:length(S),  bty='n')
#plot(S, TR)
#SIR frquency dep.
S <- 4^(0:4)
I <- 1
parmsf <- c(B=1, g=0)
parmsd <- c(B=1/16, g=0)
Months <- seq(0, 8, by=0.1)
outd <- sapply(S, function(s) {out <- ode(c(s,I,R), Months, SIR, parmsd)
out[,3]/apply(out[,2:4], 1, sum) } )
outf <- sapply(S, function(s) {out <- ode(c(s,I,R), Months, SIRf, parmsf)
out[,3]/apply(out[,2:4], 1, sum) } )
matplot(Months, outd, type='l', col=1, ylab="Prevalence (I/N)")
matplot(Months, outf, type='l', col=1, ylab="Prevalence (I/N)")
legend('bottomright', legend=S, lty=1:length(S),  bty='n')
#SIR frquency dep.
S <- 4^(0:4)
I <- 1
parmsf <- c(B=1, g=0)
parmsd <- c(B=1/16, g=0)
Months <- seq(0, 8, by=0.1)
outd <- sapply(S, function(s) {out <- ode(c(s,I,R), Months, SIR, parmsd)
out[,3]/apply(out[,2:4], 1, sum) } )
outf <- sapply(S, function(s) {out <- ode(c(s,I,R), Months, SIRf, parmsf)
out[,3]/apply(out[,2:4], 1, sum) } )
matplot(Months, outd, type='l', col=1, ylab="Prevalence (I/N)")
matplot(Months, outf, type='l', col=1, ylab="Prevalence (I/N)")
legend('bottomleft', legend=S, lty=1:length(S),  bty='n')
#6.4
#a)
N <- 10^4; I <- R <- 1; S <- N - I - R
parms <- c(B=.01, g=4)
months <- seq(0,1, by=0.01)
require(deSolve)
SIR.out <- data.frame( ode(c(S,I,R), months, SIR, parms) )
matplot(months, SIR.out[,-1], type='l', lty=1:3, col=1)
legend('right', c('R', 'I', 'S'), lty=3:1, col=3:1, bty='n')
legend('topright', c('R', 'I', 'S'), lty=3:1, col=3:1, bty='n')
#6.4
#a)
N <- 10^4; I <- R <- 1; S <- N - I - R
parms <- c(B=.01, g=4)
months <- seq(0,1, by=0.01)
require(deSolve)
SIR.out <- data.frame( ode(c(S,I,R), months, SIR, parms) )
matplot(months, SIR.out[,-1], type='l', lty=1:3, col=1)
legend('topright', c('R', 'I', 'S'), lty=3:1, col=3:1, bty='n')
#6.4
#a)
N <- 10^4; I <- R <- 1; S <- N - I - R
parms <- c(B=.01, g=4)
months <- seq(0,6, by=0.01)
require(deSolve)
SIR.out <- data.frame( ode(c(S,I,R), months, SIR, parms) )
matplot(months, SIR.out[,-1], type='l', lty=1:3, col=1)
legend('topright', c('R', 'I', 'S'), lty=3:1, col=3:1, bty='n')
#6.4
#a)
N <- 10^4; I <- R <- 1; S <- N - I - R
parms <- c(B=.01, g=4)
months <- seq(0,10, by=0.01)
require(deSolve)
SIR.out <- data.frame( ode(c(S,I,R), months, SIR, parms) )
matplot(months, SIR.out[,-1], type='l', lty=1:3, col=1)
legend('topright', c('R', 'I', 'S'), lty=3:1, col=3:1, bty='n')
#b)
SIRbd <- function(t, y, p) {
S <- y[1]; I <- y[2]; R <- y[3]
with( as.list(p), {
dS.dt <- b*(S+I+R) - B*I*S - m*S
dI.dt <- B*I*S - g*I - m*I
dR.dt <- g*I - m*R
return( list(c(dS.dt, dI.dt, dR.dt)) )
} )
}
N <- 10^6
R <- 0; I <- 1; S <- N - I - R
g <- 1/(13/365)
b <- 1/50
age <- 5
R0 <- 1 + 1/(b*age)
B <- R0 * (g + b) / N
parms <- c(B = B, g = g, b = b, m=b)
years <- seq(0,30, by=.1)
SIRbd.out <- data.frame(ode(c(S=S,I=I,R=R), years, SIRbd, parms, hmax=.01))
matplot(SIRbd.out[,1], sqrt(SIRbd.out[,-1]), type='l', col=1,
lty=1:3, ylab="sqrt(No. of Individuals)", xlab='Years')
legend('right', c('S','I','R'), lty=1:3, bty='n'
SIRbd <- function(t, y, p) {
S <- y[1]; I <- y[2]; R <- y[3]
with( as.list(p), {
dS.dt <- b*(S+I+R) - B*I*S - m*S
dI.dt <- B*I*S - g*I - m*I
dR.dt <- g*I - m*R
return( list(c(dS.dt, dI.dt, dR.dt)) )
} )
}
N <- 10^6
R <- 0; I <- 1; S <- N - I - R
g <- 1/(13/365)
b <- 1/50
age <- 10
R0 <- 1 + 1/(b*age)
B <- R0 * (g + b) / N
parms <- c(B = B, g = g, b = b, m=b)
years <- seq(0,30, by=.1)
SIRbd.out <- data.frame(ode(c(S=S,I=I,R=R), years, SIRbd, parms, hmax=.01))
matplot(SIRbd.out[,1], sqrt(SIRbd.out[,-1]), type='l', col=1,
lty=1:3, ylab="sqrt(No. of Individuals)", xlab='Years')
legend('right', c('S','I','R'), lty=1:3, bty='n'
SIRbd <- function(t, y, p) {
S <- y[1]; I <- y[2]; R <- y[3]
with( as.list(p), {
dS.dt <- b*(S+I+R) - B*I*S - m*S
dI.dt <- B*I*S - g*I - m*I
dR.dt <- g*I - m*R
return( list(c(dS.dt, dI.dt, dR.dt)) )
} )
}
N <- 10^6
R <- 0; I <- 1; S <- N - I - R
g <- 1/(13/365)
b <- 1/50
age <- 50
R0 <- 1 + 1/(b*age)
B <- R0 * (g + b) / N
parms <- c(B = B, g = g, b = b, m=b)
years <- seq(0,30, by=.1)
SIRbd.out <- data.frame(ode(c(S=S,I=I,R=R), years, SIRbd, parms, hmax=.01))
matplot(SIRbd.out[,1], sqrt(SIRbd.out[,-1]), type='l', col=1,
lty=1:3, ylab="sqrt(No. of Individuals)", xlab='Years')
legend('right', c('S','I','R'), lty=1:3, bty='n'
#b)
SIRbd <- function(t, y, p) {
S <- y[1]; I <- y[2]; R <- y[3]
with( as.list(p), {
dS.dt <- b*(S+I+R) - B*I*S - m*S
dI.dt <- B*I*S - g*I - m*I
dR.dt <- g*I - m*R
return( list(c(dS.dt, dI.dt, dR.dt)) )
} )
}
N <- 10^6
R <- 0; I <- 1; S <- N - I - R
g <- 1/(13/365)
b <- 1/50
age <- 50
R0 <- 1 + 1/(b*age)
B <- R0 * (g + b) / N
parms <- c(B = B, g = g, b = b, m=b)
years <- seq(0,30, by=.1)
SIRbd.out <- data.frame(ode(c(S=S,I=I,R=R), years, SIRbd, parms, hmax=.01))
matplot(SIRbd.out[,1], sqrt(SIRbd.out[,-1]), type='l', col=1,
lty=1:3, ylab="sqrt(No. of Individuals)", xlab='Years')
legend('right', c('S','I','R'), lty=1:3, bty='n'
library(deSolve)
SIR.derivs<-function(curr.time, myvars, params) {
gamma = 1.36 #rate at whcih uninfected CD4 lymphocytes arise
tau = 0.2 # proportiono f cells activated
p = 0.1 # proportion of cells bcoming latently infected upon infection
beta = 0.00027 # rate of infection of CD4 lymphocyptes per viron
alpha = 3.6 * 10 ^ -2 # activation rate of latently infected cells
sigma = 2 # removal rat of cell-free virus
delta = 0.33 # removal (death) rate of actively infected CD4
pie = 100 # rate of production of virions by an actively infected cell
u = 1.36 * 10^-3 # HIV-indep death reate of unifected CD4 lymphocytes
R = myvars[1]
L = myvars[2]
E = myvars[3]
V = myvars[4]
dR = gamma * tau - u * R - beta * R * V
dL = p * beta * R * V - u * L - alpha * L
dE = (1-p) * beta * R * V + alpha * L - delta * E
dV = pie * E - sigma * V
return(list(c(dR, dL, dE, dV)))
}
# use libraries to solve SIR equations
library(deSolve)
vars.ini = c(1000, 0, 0, 100) ## initial value of R is 1000 and the initial of V is 100 - based on second paragraph
mytimes = c(1:100) * 0.1 #tau values for which you want to know the output
out = ode(vars.ini, mytimes, SIR.derivs, c(1))
out
plot(out, xlab = "time", ylab = c('R','L','E','V'), main = "Changes in Infection")
setwd("C:/Users/Camille/Desktop/Fishscapes/hsSurvey")
# load function to load data from google drive
source("gdriveURL.R")
library(dplyr)
######## angling CPUE
# load creel data from google drive
creel1=gdriveURL("https://drive.google.com/open?id=1lxUd742QZMXDQunyFBnENKMYZ1XNM_Pc")
creel2=gdriveURL("https://drive.google.com/open?id=1UYhbGH28WXjmi-4BzhfwO4KYwrBCNO2Q")
creel=rbind(creel1,creel2)
# reduce to columns we care about
creel=creel[,c(1,3,6,12,18,25:26,30,36,38)]
# calculate effort
# add zeroes to times with only 2 or 3 digits
creel$timeStart[nchar(creel$timeStart)==3]=paste("0",creel$timeStart[nchar(creel$timeStart)==3],sep="")
creel$timeStart[nchar(creel$timeStart)==2]=paste("00",creel$timeStart[nchar(creel$timeStart)==2],sep="")
creel$timeStart[creel$timeStart=="0"]="0000"
creel=creel[creel$timeStart!="1",]  # 4 entries with "1", so we don't know start time
creel$timeEnd[nchar(creel$timeEnd)==3]=paste("0",creel$timeEnd[nchar(creel$timeEnd)==3],sep="")
creel$timeEnd[nchar(creel$timeStart)==2]=paste("00",creel$timeEnd[nchar(creel$timeEnd)==2],sep="")
creel$timeEnd[creel$timeEnd=="0"]="0000"
creel$boatHrs=0
# remove rows when end time is less than start time (assumes the boat was out over midnight)
creel=creel[strptime(creel$timeEnd,format="%H%M")>=strptime(creel$timeStart,format="%H%M"),]
# calculate difference of time in hours for rows where end time is greater than start time (fishing occurred in one day only)
creel$boatHrs[strptime(creel$timeEnd,format="%H%M")>=strptime(creel$timeStart,format="%H%M")]=as.numeric(difftime(strptime(creel$timeEnd[strptime(creel$timeEnd,format="%H%M")>=strptime(creel$timeStart,format="%H%M")],format="%H%M"),strptime(creel$timeStart[strptime(creel$timeEnd,format="%H%M")>=strptime(creel$timeStart,format="%H%M")],format="%H%M"),units="hours"))
# removing rows with a non-zero notFishingAmt because we don't know what it means to be non-zero...
creel=creel[creel$notFishingAmt==0,]
# remove rows with non-integer anglersAmt
creel=creel[!grepl(".",creel$anglersAmt,fixed=TRUE),]
# remove rows with anglersAmt above 10? (arbitrary choice for now)
creel=creel[creel$anglersAmt<=10,]
# get angler hours of effort from party size and boat hours
creel$anglerHrs=creel$boatHrs*creel$anglersAmt
# remove rows with no species code
creel=creel[!is.na(creel$fishSpeciesCode),]
# remove rows with NA for caughtAmt
creel=creel[!is.na(creel$caughtAmt),]
# remove no effort (anglerHrs==0) rows
creel=creel[creel$anglerHrs>0,]
# calculate angling CPUE
creel$anglingCPUE=creel$caughtAmt/creel$anglerHrs
# removing instances of CPUE >=30 (arbitrary...)
creel=creel[creel$anglingCPUE<30,]
# calculate average angling CPUE and sample size for each lake-year-species combination
lake_yearCPUE=creel %>%
group_by(WBIC,fishSpeciesCode,surveyYear,county) %>%
summarize(meanCPUE=mean(anglingCPUE),
N=n())
lake_yearCPUE=as.data.frame(lake_yearCPUE)
####### electrofishing abundance
bassEF=gdriveURL("https://drive.google.com/open?id=11v8FbT2wnKx_CqUfxu_V9r_8fyCfcdD2")
bassEF=bassEF[,c(1,3,5,13,19,27:29)]
bassEF$CPEkm=bassEF$CPEmile/1.60934   # convert fish per mile to fish per km
bassEF$distanceShockedKm=bassEF$distanceShockedMiles*0.621371 # convert miles to km
lake_yearBASSef= bassEF %>%
group_by(WBIC,species,surveyYear,county) %>%
summarize(meanEF_CPEkm=mean(CPEkm),
totalFishCaught=sum(totalNumberCaughtFish),
totalDistShockedKm=sum(distanceShockedKm),
totalHoursSampled=sum(numberHoursSampled),
std=sd(CPEkm),
N=n())
lake_yearBASSef=as.data.frame(lake_yearBASSef)
panEF=gdriveURL("https://drive.google.com/open?id=1QIqCBQ9gbOgRFUJQbnokwwTZJi5VZZIR")
panEF=panEF[,c(1,3,5,13,19,25:27)]
panEF$CPEkm=panEF$CPEmile/1.60934   # convert fish per mile to fish per km
panEF$distanceShockedKm=panEF$distanceShockedMiles*0.621371 # convert miles to km
lake_yearPANef= panEF %>%
group_by(WBIC,species,surveyYear,county) %>%
summarize(meanEF_CPEkm=mean(CPEkm),
totalFishCaught=sum(totalNumberCaughtFish),
totalDistShockedKm=sum(distanceShockedKm),
totalHoursSampled=sum(numberHoursSampled),
std=sd(CPEkm),
N=n())
lake_yearPANef=as.data.frame(lake_yearPANef)
walleyeEF=gdriveURL("https://drive.google.com/open?id=1DPRROWv6Cf_fP6Z-kE9ZgUfdf_F_jSNT")
walleyeEF=walleyeEF[,c(1,3,5,13,19,23:24,27)]
walleyeEF$CPEkm=walleyeEF$CPEmile/1.60934   # convert fish per mile to fish per km
walleyeEF$distanceShockedKm=walleyeEF$distanceShockedMiles*0.621371 # convert miles to km
#remove commas from total fish caught
walleyeEF$totalNumberCaughtFish=as.numeric(gsub(",","",walleyeEF$totalNumberCaughtFish))
lake_yearWALLef= walleyeEF %>%
group_by(WBIC,species,surveyYear,county) %>%
summarize(meanEF_CPEkm=mean(CPEkm),
totalFishCaught=sum(totalNumberCaughtFish),
totalDistShockedKm=sum(distanceShockedKm),
totalHoursSampled=sum(numberHoursSampled),
std=sd(CPEkm),
N=n())
lake_yearWALLef=as.data.frame(lake_yearWALLef)
##### merge data sets from angling CPUE and electrofishing CPUE to get exact lake-year matches
# convert fishSpeciesCode in lake_yearCPUE to species (name from ef stuff)
lake_yearCPUE$species=""
lake_yearCPUE$species[lake_yearCPUE$fishSpeciesCode=="X22"]="WALLEYE"
lake_yearCPUE$species[lake_yearCPUE$fishSpeciesCode=="W11"]="SMALLMOUTH BASS"
lake_yearCPUE$species[lake_yearCPUE$fishSpeciesCode=="W12"]="LARGEMOUTH BASS"
lake_yearCPUE$species[lake_yearCPUE$fishSpeciesCode=="X15"]="YELLOW PERCH"
lake_yearCPUE$species[lake_yearCPUE$fishSpeciesCode=="W14"]="BLACK CRAPPIE"
lake_yearCPUE$species[lake_yearCPUE$fishSpeciesCode=="W09"]="BLUEGILL"
# trim species without EF data (can we get other species EF data?)
lake_yearCPUE=lake_yearCPUE[lake_yearCPUE$species!="",]
bassJoin=left_join(lake_yearBASSef,lake_yearCPUE,by=c("WBIC"="WBIC","species"="species","surveyYear"="surveyYear", "county"="county"))
bassJoin=bassJoin[!is.na(bassJoin$meanCPUE),]
panJoin=left_join(lake_yearPANef,lake_yearCPUE,by=c("WBIC"="WBIC","species"="species","surveyYear"="surveyYear", "county"="county"))
panJoin=panJoin[!is.na(panJoin$meanCPUE),]
wallJoin=left_join(lake_yearWALLef,lake_yearCPUE,by=c("WBIC"="WBIC","species"="species","surveyYear"="surveyYear", "county"="county"))
wallJoin=wallJoin[!is.na(wallJoin$meanCPUE),]
table(lake_yearCPUE$species)
nrow(lake_yearBASSef)
nrow(bassJoin)
nrow(lake_yearPANef)
nrow(panJoin)
nrow(lake_yearWALLef)
nrow(wallJoin)
library(ggplot2)
length(unique(lake_yearBASSef$county=="ASHLAND")))
length(unique(lake_yearBASSef$county=="ASHLAND"))
length(unique(lake_yearBASSef$county=="BAYFIELD"))
length(unique(lake_yearBASSef$county=="VILAS"))
VILASbass<-grep(lake_yearBASSef$county=="VILAS")
VILASbass<-grep(lake_yearBASSef$county=="VILAS",)
VILASbass<-grep(,lake_yearBASSef$county=="VILAS")
VILASbass<-grep(lake_yearBASSef[lake_yearBASSef$county=="VILAS"])
VILASbass<-grep(lake_yearBASSef[lake_yearBASSef$county=="VILAS"],)
VILASbass<-grep(lake_yearBASSef[lake_yearBASSef$county=="VILAS",])
unique(lake_yearBASSef$county=="ASHLAND")
unique(lake_yearBASSef$county)
VILASbass<-lake_yearBASSef[lake_yearBASSef$county=="VILAS",]
View(VILASbass)
length(lake_yearBASSef[lake_yearBASSef$county=="VILAS",])
View(VILASbass)
length(lake_yearBASSef[,lake_yearBASSef$county=="VILAS"])
unique(VILASbass$WBIC)
length(unique(VILASbass$WBIC))
ASHbass<-lake_yearBASSef[lake_yearBASSef$county=="ASHLAND",]
length(unique(ASHbass$WBIC))
BAYbass<-lake_yearBASSef[lake_yearBASSef$county=="BAYFIELD",]
length(unique(BAYbass$WBIC))
DOUHbass<-lake_yearBASSef[lake_yearBASSef$county=="DOUGLAS",]
length(unique(DOUHbass$WBIC))
IRONbass<-lake_yearBASSef[lake_yearBASSef$county=="IRON",]
length(unique(IRONbass$WBIC))
LANbass<-lake_yearBASSef[lake_yearBASSef$county=="LANGLADE",]
length(unique(LANbass$WBIC))
LINbass<-lake_yearBASSef[lake_yearBASSef$county=="LINCOLN",]
length(unique(LINbass$WBIC))
OCObass<-lake_yearBASSef[lake_yearBASSef$county=="OCONTO",]
length(unique(OCObass$WBIC))
ONbass<-lake_yearBASSef[lake_yearBASSef$county=="ONEIDA",]
length(unique(ONbass$WBIC))
WAbass<-lake_yearBASSef[lake_yearBASSef$county=="WASHBURN",]
length(unique(WAbass$WBIC))
length(unique(ASHpan$WBIC))
ASHpan<-lake_yearPANef[lake_yearPANef$county=="ASHLAND",]
length(unique(ASHpan$WBIC))
BAYpan<-lake_yearPANef[lake_yearPANef$county=="BAYFIELD",]
length(unique(BAYpan$WBIC))
DOUpan<-lake_yearPANef[lake_yearPANef$county=="DOUGLAS",]
length(unique(DOUpan$WBIC))
IROpan<-lake_yearPANef[lake_yearPANef$county=="IRON",]
length(unique(IROpan$WBIC))
LANpan<-lake_yearPANef[lake_yearPANef$county=="LANGLADE",]
length(unique(LANpan$WBIC))
LINpan<-lake_yearPANef[lake_yearPANef$county=="LINCOLN",]
length(unique(LINpan$WBIC))
OCOpan<-lake_yearPANef[lake_yearPANef$county=="OCONTO",]
length(unique(OCOpan$WBIC))
ONpan<-lake_yearPANef[lake_yearPANef$county=="ONEIDA",]
length(unique(ONpan$WBIC))
VIpan<-lake_yearPANef[lake_yearPANef$county=="VILAS",]
length(unique(VIpan$WBIC))
WApan<-lake_yearPANef[lake_yearPANef$county=="WASHBURN",]
length(unique(WApan$WBIC))
EUpan<-lake_yearPANef[lake_yearPANef$county=="EAU CLAIRE",]
length(unique(EUpan$WBIC))
ASHwall<-lake_yearWALLef[lake_yearWALLef$county=="ASHLAND",]
length(unique(ASHwall$WBIC))
BAYwall<-lake_yearWALLef[lake_yearWALLef$county=="BAYFIELD",]
length(unique(BAYwall$WBIC))
DOUwall<-lake_yearWALLef[lake_yearWALLef$county=="DOUGLAS",]
length(unique(DOUwall$WBIC))
IRwall<-lake_yearWALLef[lake_yearWALLef$county=="IRON",]
length(unique(IRwall$WBIC))
LAwall<-lake_yearWALLef[lake_yearWALLef$county=="LANGLADE",]
length(unique(LAwall$WBIC))
LNwall<-lake_yearWALLef[lake_yearWALLef$county=="LINCOLN",]
length(unique(LNwall$WBIC))
OCwall<-lake_yearWALLef[lake_yearWALLef$county=="OCONTO",]
length(unique(OCwall$WBIC))
ONwall<-lake_yearWALLef[lake_yearWALLef$county=="ONEIDA",]
length(unique(ONwall$WBIC))
Vwall<-lake_yearWALLef[lake_yearWALLef$county=="VILAS",]
length(unique(Vwall$WBIC))
Wwall<-lake_yearWALLef[lake_yearWALLef$county=="WASHBURN",]
length(unique(Wwall$WBIC))
