#Next we create side-by-side plots, using both arithmetic and logarithmic scales, and
#add a legend.
layout(matrix(1:2, nrow = 1))
matplot(t, cont.mat, type = "l", ylab = "N", col = 1)
legend("topleft", paste(rev(r)), lty = 5:1, col = 1, bty = "n",
+ title = "r")
matplot(t, cont.mat, type = "l", ylab = "N", log = "y", col = 1)
m.time <- function(r, m = 2) {
+ log(m)/r
+ }
#creating a function for doubling time
m.time <- function(r, m = 2) {log(m)/r}
#Now we create a vector of r, and then use m.time to generate a vector of doublingtimes.
rs <- c(0, 1, 2)
m.time(rs)
matplot(t, cont.mat, type = "l", ylab = "N", log = "y", col = 1)
#Chapter 1 problems:
#1
N <- c(150,100,125,200,225,150,100,175,100,150)
year <- 1996:2005
plot(year, N)
plot(year, N)
rates = N[2:10]/N[1:9]
rates
#[1] 0.6666667 1.2500000 1.6000000 1.1250000 0.6666667 0.6666667 1.7500000 0.5714286 1.5000000
plot(year,rates)
#A Primer in Ecology in R Notes
#Chapter 1: pdf (p.1-40)
#Simple Graphing of Population Size (Fig. 1.3)Here we create two vectors:
#population size (N), and years. Using c() allows us to
#create an arbitrary vector, and the colon, :, provides a sequence of consecutive integers.
N <- c(1, 3, 9, 27, 81)
year <- 2001:2005
#Here we divide each element of one vector (the second through fifth element of N)
#by each element of another vector (the first through fourth elements of N).
rates = N[2:5]/N[1:4]
rates
#Chapter 1 problems:
#1
N <- c(150,100,125,200,225,150,100,175,100,150)
year <- 1996:2005
plot(year, N)
rates = N[2:10]/N[1:9]
rates
#[1] 0.6666667 1.2500000 1.6000000 1.1250000 0.6666667 0.6666667 1.7500000 0.5714286 1.5000000
plot(year[2:10],rates)
plot(year,rates)
N0 <- year[1]
N0 <- 1996
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
Popgr <- PopCount[2:(t + 1)]/PopCount[1:t]
PopCount <- N[1:(t + 1), ]
data.frame(x=year,y=N)
Pop<-data.frame(x=year,y=N)
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
Popgr <- Pop[2:(year + 1)]/Pop[1:year]
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
Popgr <- Pop[2:(t + 1)]/Pop[1:t]
#2
m.time <- function(r, m = 2) {log(m)/r}
#Now we create a vector of r, and then use m.time to generate a vector of doublingtimes.
rs <- c(0, 1, 2)
m.time(rs)
triple.time <- function(r, m = 3) {log(m)/r}
triple.time(rs)
#3
#intrinsic rate of increase 630 million in 1700, 6.3 billion
N <- c(6300000,63000000000)
year <- (1700,2003)
install.packages("primer")
#Chapter 1 problems:
#1
N <- c(150,100,125,200,225,150,100,175,100,150)
year <- 1996:2005
plot(year, N)
rates = N[2:10]/N[1:9]
rates
#[1] 0.6666667 1.2500000 1.6000000 1.1250000 0.6666667 0.6666667 1.7500000 0.5714286 1.5000000
plot(year[2:10],rates)
avgrate <- sum(rates/9)
#Comparing arithmetic and geometric averages (Fig. 1.5)
#First we select the number of observed R (t = 5); this will require that we use six
#years of Song Sparrow data.
t <- 5
SS6 <- sparrows[1:(t + 1), ]
head(sparrows)
read.csv(sparrows)
load(sparrows)
#A Primer in Ecology in R Notes
#Chapter 1: pdf (p.1-40)
library(primer)
#Comparing arithmetic and geometric averages (Fig. 1.5)
#First we select the number of observed R (t = 5); this will require that we use six
#years of Song Sparrow data.
t <- 5
SS6 <- sparrows[1:(t + 1), ]
install.packages(PET)
PopSim <- function(Rs, N0, years = 50, sims = 10) {
sim.RM = matrix(sample(Rs, size = sims * years, replace = TRUE),
nrow = years, ncol = sims)
output <- numeric(years + 1)
output[1] <- N0
outmat <- sapply(1:sims, function(i) {
for (t in 1:years) output[t + 1] <- round(output[t] * sim.RM[t, i], 0)
output
})
return(outmat)
}
system.time(output <- PopSim(Rs = obs.R, N0 = 43, sims = 1000))
output <- PopSim(Rs = obs.R, N0 = 43, sims = 1000)
PopSim <- function(Rs, N0, years = 50, sims = 10) {
sim.RM = matrix(sample(Rs, size = sims * years, replace = TRUE),
nrow = years, ncol = sims)
output <- numeric(years + 1)
output[1] <- N0
outmat <- sapply(1:sims, function(i) {
for (t in 1:years) output[t + 1] <- round(output[t] * sim.RM[t, i], 0)
output
})
return(outmat)
}
projection <- 150*[(1.08)^30]
projection <- 150*(1.08)^30
projection <- 150*(1.08)^20
#1B
R=N[-1]/N[-length(N)]
plot(years[-length(years)],R,type='p')
Rbar.A=mean(R)
Rba.G=prod(R)^(1/length(R))
projection <- 150*Rbar.A^20
projection <- 150*Rbar.A^30
#A primer of Ecology in R
#Chapter2 Density independent demography
#Matrices in R
M <- matrix(1:4, nr = 2, byrow = T)
M
N <- matrix(c(10, 20, 30, 40), nr = 2)
N
M %*% N
A <- matrix(c(0, 0.5, 20, 0.3, 0, 0, 0, 0.5, 0.9), nr = 3, byrow = TRUE)
N0 <- matrix(c(100, 250, 50), ncol = 1)
N1 <- A %*% N0
N1
#project population over six years using a for loop,each year depends on the previous year
years <- 6
N.projections <- matrix(0, nrow = nrow(A), ncol = years + 1)
N.projections[, 1] <- N0
for (i in 1:years) N.projections[, i + 1] <- A %*% N.projections[,i]
matplot(0:years, t(N.projections), type = "l", lty = 1:3, col = 1, ylab = "Stage Abundance", xlab = "Year")
legend("topleft", legend = c("Seeds", "Small Adult", "Large Adult"),lty = 1:3, col = 1, bty = "n")
#calculating annual growth
N.totals <- apply(N.projections, 2, sum)
Rs <- N.totals[-1]/N.totals[-(years + 1)]
#plot R for each year(t)
plot(0:(years - 1), Rs, type = "b", xlab = "Year", ylab = "R")
#Eigenanalysis in R
eigs.A <- eigen(A)
eigs.A
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
#Eigenanalysis in R
eigs.A <- eigen(A)
eigs.A
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A["values"])
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
L1 <- Re(eigs.A[["values"]][dom.pos])
L1
#Power iteration method of eigenanalysis, mulitplying projection matrix by stage structure again
t<-20
Nt<- N0/sum(N0)
#for-loop that re-uses Nt for each time step, making empty numeric vector to hold the output.
R.t <- numeric(t)
for (i in 1:t) R.t[i] <- {
Nt1 <- A %*% Nt
R <- sum(Nt1)/sum(Nt)
Nt <- Nt1/sum(Nt1)
R
}
#Comparing results to estimate of lambda
par(mar = c(5, 4, 3, 2))
plot(1:t, R.t, type = "b", main = quote("Convergence Toward " * lambda))
points(t, L1, pch = 19, cex = 1.5)
#calculating stable stage distribution, as N approaches constant rates relative abundance can be found
# SSD = w1/sum of W1 elements
w <- Re(eigs.A[["vectors"]][, dom.pos])
ssd <- w/sum(w)
round(ssd, 3)
#calculating reproductive value
M <- eigen(t(A))
v <- Re(M$vectors[, which.max(Re(M$values))])
RV <- v/v[1]
RV
#calculating sensitivities of matrix
s <- v %*% t(w)
(S <- vw.s/as.numeric(v %*% w))
S <- vw/as.numeric(v %*% w)
S <- v*ws/as.numeric(v %*% w)
N0 <- matrix(c(0,10,10,10,10,10))
A <- matrix(c(0,0,0,0,0,1.642,0.098,0,0,0,0,0.437,0,0.342,
0.591,0.050,0.095,0,0,0.026,0.295,0.774,
0.177,0.194,0,0,0,0.145,0.596,0.362,0,0,0,
0.016,0.277,0.489),nr=6,byrow=T)
years <- 10
N.projections <- matrix(0,nrow=nrow(A), ncol=years+1)
N.projections[,1] <- N0
for (i in 1:years){
N.projections[,i+1] <- A%*%N.projections[,i]
}
matplot(0:years,t(N.projections), type="l", lty=1:10,col=1,
ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("Seedling", "Small 1-leaved Plant",
"Medium 1-leaved Plant", "Large 1-leaved Plant",
"Fertile Plant"),
lty=1:6, col=1, bty="n")
# c)
eigs.A <- eigen(A)
dom.pos <- which.max(eigs.A[["values"]])
w <- Re(eigs.A[["vectors"]][,dom.pos])
ssd <- w/sum(w)
round(ssd,3)
#d) Calculating lambda
L1 <- Re(eigs.A[["values"]][dom.pos])
# e) Calculating elasticities
M <- eigen(t(A))
v <- Re(M$vectors[, which.max(Re(M$values))])
vw.s <- v %*% t(w)
S <- vw.s/as.numeric(v %*% w)
elas <- (A/L1) * S
round(elas,3)
#2.2
M<- matrix(c(0,0,0,0,127,4,80,
0.6747, 0.7370,0,0,0,0,0,
0,0.0486,0.6610,0,0,0,0,
0,0,0.0147,0.6907,0,0,0,
0,0,0,0.0518,0,0,0,
0,0,0,0,0.8091,0,0,
0,0,0,0,0,0.8091,0.8089), nr=7, byrow=T)
M
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
for (i in 1:time){
N.projections[,i+1] <- M%*%N.projections[,i]
}
# working on stable stage distribution
eigs.M <- eigen(M)
dom.pos <- which.max(eigs.M[["values"]])
w <- Re(eigs.M[["vectors"]][,dom.pos])
ssd <- w/sum(w)
round(ssd,4)
#calculate lambda
lambda <- Re(eigs.M[["values"]][dom.pos])
lambda #0.945031
#detmine elasticities
M.new <- eigen(t(M))
v <- Re(M.new$vectors[, which.max(Re(M.new$values))])
vw.s <- v %*% t(w)
S <- vw.s/as.numeric(v %*% w)
elas <- (M/lambda) * S
round(elas,3)
#graph this for 10 years
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("eggs,hatchlines", "small juveniles", "large juveniles", "subadults", "novice breeders", "1st-yr remigrants", "mature breeders"), lty=1:7, col=1, bty="n")
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("eggs,hatchlines", "small juveniles", "large juveniles", "subadults", "novice breeders", "1st-yr remigrants", "mature breeders"), lty=1:7, col=1, bty="n")
#graph this for 10 years
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
#Simple Numerical Evaluation of rd (Fig. 3.5)
#Here we vary rd by creating a short systematic sequence rd = 1.3, 1.6, . . . , 2.8. We set
#t = 50, and use dlogistic to create a trajectory for each of the six rd.
rd.v <- seq(1.3, 2.8, by = 0.3)
t <- 15
Ns <- data.frame(sapply(rd.v, function(r) dlogistic(rd = r, t = t)))
library(primer)
#Writing a Function For Discrete Logistic Growth
#An R function will simplify our explorations. It will return a vector of N, given ,
#rd, N0, and t. The function arguments can have defaults (e.g., t=10).
dlogistic <- function(alpha = 0.01, rd = 1, N0 = 2, t = 15) {
N <- c(N0, numeric(t))
for (i in 1:t) N[i + 1] <- {
N[i] + rd * N[i] * (1 - alpha * N[i])
}
return(N)
}
#Graphing Population Size
#We can use the function created above, dlogistic, with default settings, to generate
#a population projection.
> Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
> t <- 15; a <- 0.01
> plot(0:t, Nts)
> abline(h = 1/a, lty = 3)
#(Per Capita) Population Growth Increment vs. N (Fig. 3.3)
#Using the previous projection, we now capture both the total and the per capita
#growth increment per unit time, from t to t+1. We graph these versus Nt, population
#size at t.
total.incr <- Nts[1:t + 1] - Nts[1:t]
per.capita.incr <- total.incr/Nts[1:t]
Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
t <- 15; a <- 0.01
plot(0:t, Nts)
abline(h = 1/a, lty = 3)
Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
t <- 15; a <- 0.01
plot(0:t, Nts)
abline(h = 1/a, lty = 3)
#(Per Capita) Population Growth Increment vs. N (Fig. 3.3)
#Using the previous projection, we now capture both the total and the per capita
#growth increment per unit time, from t to t+1. We graph these versus Nt, population
#size at t.
total.incr <- Nts[1:t + 1] - Nts[1:t]
per.capita.incr <- total.incr/Nts[1:t]
plot(Nts[1:t], total.incr)
plot(Nts[1:t], per.capita.incr)
#Numerical Evaluation of Initial Conditions (Fig. 3.4a)
#Here we draw randomly 30 N0 from a uniform distribution between zero and 1.2K.
#We also include zero specifically. We then use sapply to run dlogistic for each N0,
#using defaults for the other arguments.
N0s <- c(0, runif(30) * 1.1 * 1/a)
N <- sapply(N0s, function(n) dlogistic(N0 = n))
matplot(0:t, N, type = "l", lty = 1, lwd = 0.75, col = 1)
text(t, 1/a, expression(italic("K") == 1/alpha), adj = c(1,0))
#Numerical Evaluation of  (Fig. 3.4b)
#Here we draw 30 random K from a uniform distribution from 50 to 1000, and convert
#these to . We use sapply to run dlogistic for each .
a.s <- 1/runif(30, min = 50, max = 1000)
#Numerical Evaluation of  (Fig. 3.4b)
#Here we draw 30 random K from a uniform distribution from 50 to 1000, and convert
#these to. We use sapply to run dlogistic for each .
a.s <- 1/runif(30, min = 50, max = 1000)
N <- sapply(a.s, function(a) dlogistic(alpha = a, t = 15))
#We next plot all populations, and use some fancy code to add some informative text
#in the right locations.
matplot(0:t, N, type = "l", ylim = c(0, 1000), lty = 1, lwd = 0.75,col = 1)
text(8, 1/min(a.s), bquote(italic(alpha) == .(round(min(a.s),3))), adj = c(1, 0.5))
text(10, 1/max(a.s), bquote(italic(alpha) == .(round(max(a.s),3))), adj = c(0, 1.2))
#Simple Numerical Evaluation of rd (Fig. 3.5)
#Here we vary rd by creating a short systematic sequence rd = 1.3, 1.6, . . . , 2.8. We set
#t = 50, and use dlogistic to create a trajectory for each of the six rd.
rd.v <- seq(1.3, 2.8, by = 0.3)
t <- 15
Ns <- data.frame(sapply(rd.v, function(r) dlogistic(rd = r, t = t)))
matplot(0:t, Ns, type = "l", col = 1)
library(primer)
#Writing a Function For Discrete Logistic Growth
#An R function will simplify our explorations. It will return a vector of N, given ,
#rd, N0, and t. The function arguments can have defaults (e.g., t=10).
dlogistic <- function(alpha = 0.01, rd = 1, N0 = 2, t = 15) {
N <- c(N0, numeric(t))
for (i in 1:t) N[i + 1] <- {
N[i] + rd * N[i] * (1 - alpha * N[i])
}
return(N)
}
#Graphing Population Size
#We can use the function created above, dlogistic, with default settings, to generate
#a population projection.
Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
t <- 15; a <- 0.01
plot(0:t, Nts)
abline(h = 1/a, lty = 3)
#(Per Capita) Population Growth Increment vs. N (Fig. 3.3)
#Using the previous projection, we now capture both the total and the per capita
#growth increment per unit time, from t to t+1. We graph these versus Nt, population
#size at t.
total.incr <- Nts[1:t + 1] - Nts[1:t]
per.capita.incr <- total.incr/Nts[1:t]
plot(Nts[1:t], total.incr)
plot(Nts[1:t], per.capita.incr)
#Chapter 3 problem
#3.1
#rd of an annual plant that has a maximum growth rate of Nt+1/Nt=2 at very, very small population sizes
rd <- 0
t <- 15
Ns <- data.frame(sapply(rd.v, function(r) dlogistic(rd = r, t = t)))
matplot(0:t, Ns, type = "l", col = 1)
#Chapter 3 problem
#3.1
#a) rd of an annual plant that has a maximum growth rate of Nt+1/Nt=2 at very, very small population sizes
rd = 1
#b)calculate alpha
alpha = 1/100
#c)calculate logisitc growth equation
dlogistic <- function(alpha,rd,N0,t) {
N = c(N0, numeric(t))
for(i in 1:t) {
N[i+1] = N[i] + rd * N[i] * (1 - alpha * N[i])
}
return(N)
}
#d) graph for 10 years
dlogis = dlogistic(alpha, rd, 1, 10)
plot(0:10,dlogis)
plot(ylab="years", y = 0:10,dlogis)
plot(xlab="years", x = 0:10,dlogis)
plot(xlab="years",ylab = "growth" x = 0:10,dlogis)
plot(xlab="years",ylab = "growth", x = 0:10,dlogis)
clogistic <- function(times, y, parms) {
n = y[1]
r = parms[1]
alpha = parms[2]
dN.dt = r*n*(1-alpha*n)
return(list(c(dN.dt)))
}
prms = c(r = r, alpha = alpha)
init.N = c(1000)
t.s = seq(0.1,50, by = 1)
out = ode(y = init.N, times = t.s, clogistic, parms = prms)
plot(out[, 1], out[, 2], type = "l", xlab = "Time", ylab = "N")
clogistic <- function(times, y, parms) {
n = y[1]
r = parms[1]
alpha = parms[2]
dN.dt = r*n*(1-alpha*n)
return(list(c(dN.dt)))
}
prms = c(r = r, alpha = alpha)
n = y[1]
r = parms[1]
alpha = parms[2]
dN.dt = r*n*(1-alpha*n)
library(primer)
thetalogistic <- function(times, y, parms) {
n = y[1]
with(as.list(parms), {
dN.dt = r * n * (1 - (alpha * n)^theta)
return(list(c(dN.dt)))
})
}
#b)show that theta=1
prms = c(r = r, alpha = alpha)
r <- 0.75
alpha <- 0.01
theta <- c(0.5, 1, 2)
N <- 0:110
theta.out <- sapply(theta, function(th) {
1 - (alpha * N)^th
})
matplot(N, theta.out, type = "l", col = 1)
abline(h = 0)
legend("topright", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
matplot(N, theta.out, ylab="theta",type = "l", col = 1)
abline(h = 0)
legend("topright", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
legend("bottomleft", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
r <- 0.75
alpha <- 0.01
theta <- c(0.5, 1, 2)
N <- 0:110
theta.out <- sapply(theta, function(th) {
1 - (alpha * N)^th
})
matplot(N, theta.out, ylab="theta",type = "l", col = 1)
abline(h = 0)
legend("bottomleft", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
#3.5
#discrete version of the logistic growth model
Kstart = 100
time = 1:20
K = numeric(20)
for(i in 1:20) {
K[i] = Kstart + rnorm(1, m=0, sd=5)
}
plot(time, K)
dlogistic <- function(K,rd,N0,t) {
N = c(N0, numeric(t))
for(i in 1:t) {
N[i+1] = N[i] + rd * N[i] * (1 - (1/K[i]) * N[i])
}
return(N)
}
d = dlogistic(K, rd, 1, 20)
plot(0:20,d)
plot(ylab="growth", xlab="years",0:20,d)
#b)
rd = 1
Nsim = 100
N_mean = numeric(Nsim)
S_D = numeric(Nsim)
for (j in 1:Nsim){
stdev = sample(seq(0.1,15,0.5),1)
S_D[j] = stdev
Kstart = 100
time = 1:20
K = numeric(20)
for(i in 1:20) {
K[i] = Kstart + rnorm(1, m=0, sd=stdev)
}
N_mean[j] = mean(dlogistic(K, rd, 1, 20))
}
plot(S_D, N_mean)
plot(xlab="standard deviation",ylab="Mean",S_D, N_mean)
setwd("C:/Users/Camille/Desktop/Fishscapes/hsSurvey")
