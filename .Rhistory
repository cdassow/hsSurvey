local({pkg <- select.list(sort(.packages(all.available = TRUE)),graphics=TRUE)
if(nchar(pkg)) library(pkg, character.only=TRUE)})
q()
#Vectors
#Logical
vtrl= c(TRUE,FALSE)
class(vtrl)
vtr2=c(15,85.68938,999999)
class(vtrl)
vtr2
class(vtr2)
vtr3=c(35L,58L,146L)
vtr3
class(vtr3)
vtr4=c(58.467L)
vtr5=c("Hello", FALSE, 65L)
vtr5
class(vtr5)
mtr= matrix(c(5:30),5,5)
mtr= matrix(c(5:29),5,5)
mtr
arr = array(c(1:9),dim = c(3,3,4,2))
arr
vtr7 =c(5.678,32,95,31.6)
vtr8=c("Hey", "How are you?","Thank you")
my list= list(vtr7,vtr8,vtr1)
my list = list(vtr7,vtr8,vtr1)
mylist = list(vtr7,vtr8,vtr1)
mylist = list(vtr7,vtr8,vtr2)
my list
mylist
#dataframe
vtr1 =c(1:5)
vtr2 = c("Neel","jude", "Adam","Adithya","Swetha")
vtr3 = c(15,25,65,145,74)
data.frame(vtr1,vtr2,vtr3)
print(6+9.87)
print(6/9.87)
#modular operation- to get division remainder
print(6%%9.87)
print(22/7)
print(22%%7)
#floor division rounds
print(22%/%7)
var = 25
var1 = 60
print(var==var1)
print(var !=var1)
value1= c(TRUE,FALSE, TRUE, FALSE)
value2= c(FALSE, TRUE, TRUE, FALSE)
print(value1 & value2)
print(value1|value2)
print(value1||value2)
#getting data for hunter
lmb=fishIS[fishIS$lakeID=="HT" & fishIS$species=="largemouth_bass",]
#putting samples into batches for one sampling night of work
#adding a column for batches
lmb$batch=numeric(nrow(lmb))
samp=unique(lmb$sampleID)
samp
#check times to sort batches
lmb$batch[lmb$sampleID%in%samp[1:4]]=1
lmb$batch[lmb$sampleID%in%samp[5:7]]=2
lmb$batch[lmb$sampleID%in%samp[8:11]]=3
lmb$batch[lmb$sampleID%in%samp[12]]=4
lmb$batch[lmb$sampleID%in%samp[13:15]]=5
#collected now
collectedNow=count(lmb, batch)
#marked now
markedNow=lmb%>%
group_by(batch)%>%
filter(clipApply=="AF")%>%
summarize(markedNow=n())
#recaptured now
recapturedNow=lmb%>%
group_by(batch)%>%
filter(clipRecapture=="AF")%>%
summarize(recapturedNow=n())
#combinbing collected, mark, recap data
recapStats=merge(collectedNow, markedNow, by="batch", all=T)
recapStats=merge(recapStats, recapturedNow, by="batch", all=T)
#check for 0s to fill in then run next line
recapStats$recapturedNow[c(2:3)]=0 # no recaps on the first and second samples
#calculate markedPrior for each sample
recapStats$markedPrior=numeric(nrow(recapStats)) #fills in all 0s, which is what we want for the first sample anyway
for(i in 2:nrow(recapStats)){
recapStats$markedPrior[i]=recapStats$markedNow[i-1]+recapStats$markedPrior[i-1]
}
recapStats
# PE, change PE for name of lake
HTpe=schnabel(markedPrior = recapStats$markedPrior, collectedNow = recapStats$n, recapturedNow = recapStats$recapturedNow )
HTpe
#assign to summary dataframe
#lines 54-99 code for lmb PE with lake, change row number for empty spot on PE table
PEs[1,]=c("HT","largemouth_bass", max(HTpe$event), HTpe[max(nrow(HTpe)),3], HTpe[max(nrow(HTpe)),2], HTpe[max(nrow(HTpe)),4])
smb=fishIS[fishIS$lakeID=="HT" & fishIS$species=="smallmouth_bass",]
if(nrow(smb[smb$clipRecapture=="AF",])>5){
#putting samples into batches for one sampling night of work
#adding a column for batches
smb$batch=numeric(nrow(smb))
samp=unique(smb$sampleID)
samp
smb$batch[smb$sampleID%in%samp[1:3]]=1
smb$batch[smb$sampleID%in%samp[4:6]]=2
smb$batch[smb$sampleID%in%samp[7:10]]=3
smb$batch[smb$sampleID%in%samp[11]]=4
smb$batch[smb$sampleID%in%samp[12:14]]=5
#collected now
collectedNow=count(smb, batch)
#marked now
markedNow=smb%>%
group_by(batch)%>%
filter(clipApply=="AF")%>%
summarize(markedNow=n())
#recaptured now
recapturedNow=smb%>%
group_by(batch)%>%
filter(clipRecapture=="AF")%>%
summarize(recapturedNow=n())
#combinbing collected, mark, recap data
recapStats=merge(collectedNow, markedNow, by="batch", all=T)
recapStats=merge(recapStats, recapturedNow, by="batch", all=T)
recapStats$recapturedNow[1:2]=0 # no recaps on the first and second samples
#calculate markedPrior for each sample
recapStats$markedPrior=numeric(nrow(recapStats)) #fills in all 0s, which is what we want for the first sample anyway
for(i in 2:nrow(recapStats)){
recapStats$markedPrior[i]=recapStats$markedNow[i-1]+recapStats$markedPrior[i-1]
}
recapStats
# PE
HTpe=schnabel(markedPrior = recapStats$markedPrior, collectedNow = recapStats$n, recapturedNow = recapStats$recapturedNow )
HTpe
#assign to summary dataframe
PEs[2,]=c("HT","smallmouth_bass", max(HTpe$event), HTpe[max(nrow(HTpe)),3], HTpe[max(nrow(HTpe)),2], HTpe[max(nrow(HTpe)),4])
}else{
PEs[2,]=c("HT","smallmouth_bass", rep(NA,4))
print("not enough SMB captured for PE at HT")
}
#getting data for hunter
lmb=fishIS[fishIS$lakeID=="HT" & fishIS$species=="largemouth_bass",]
#putting samples into batches for one sampling night of work
#adding a column for batches
lmb$batch=numeric(nrow(lmb))
samp=unique(lmb$sampleID)
samp
#check times to sort batches
lmb$batch[lmb$sampleID%in%samp[1:4]]=1
load("~/Fishscapes/fishSamplesIS.csv")
load("~/Fishscapes/fishInfoIS.csv")
full=read.csv("pe_cpue_ModelBuild.csv", header = T, stringsAsFactors = F)
getwd()
setwd("C:/Users/Camille/Desktop/Fishscapes/hsSurvey/")
getwd()
full=read.csv("pe_cpue_ModelBuild.csv", header = T, stringsAsFactors = F)
ggplot(full,aes(x=fishPerKM, y=lkmeanCPE))+
geom_point()+geom_text(aes(label=lakeID), hjust=-0.5, vjust=-1)
ggplot()
ggplot2(full,aes(x=fishPerKM, y=lkmeanCPE))+
geom_point()+geom_text(aes(label=lakeID), hjust=-0.5, vjust=-1)
install.packages("ggplot2")
ggplot(full,aes(x=fishPerKM, y=lkmeanCPE))+
geom_point()+geom_text(aes(label=lakeID), hjust=-0.5, vjust=-1)
full=read.csv("pe_cpue_ModelBuild.csv", header = T, stringsAsFactors = F)
ggplot(full,aes(x=fishPerKM, y=lkmeanCPE))+
geom_point()+geom_text(aes(label=lakeID), hjust=-0.5, vjust=-1)
update.packages()
ggplot
ggplot(full,aes(x=fishPerKM, y=lkmeanCPE))+
geom_point()+geom_text(aes(label=lakeID), hjust=-0.5, vjust=-1)
installed.packages(ggplot)
installed.packages(ggplot2)
install.packages("ggplot2")
install.packages("ggplot2")
installed.packages(ggplot2)
ggplot(full,aes(x=fishPerKM, y=lkmeanCPE))+
geom_point()+geom_text(aes(label=lakeID), hjust=-0.5, vjust=-1)
#glm fits
fit0=lm(full$lkmeanCPE~full$fishPerKM)
summary(fit0)
fitCond=lm(full$lkmeanCPE~full$fishPerKM+full$conductance)
<<<<<<< HEAD
summary(fitCond)
summary(fitCond)
fitCDepthSize=lm(full$lkmeanCPE~full$fishPerKM+full$conductance+full$maxDepth+full$maxSize)
summary (fitCDepthSize)
#testing models
summary(lm(full$lkmeanCPE~full$conductance+full$surfaceArea+full$maxDepth))#R2 -0.19, p 0.8279
summary(lm(full$lkmeanCPE~full$maxSize+full$perimeter))#R2 -0.05905, p 0.547
summary(lm(full$lkmeanCPE~full$conductivityQuintile+full$perimeter))#R2 0.05712, p 0.3722
summary(lm(full$lkmeanCPE~full$maxSize+full$maxDepth+full$surfaceArea))#R2 -0.1043, p 0.6528
summary(lm(full$lkmeanCPE~full$fishPerKM+full$conductance))#R2 0.01587, p 0.371
summary(lm(full$lkmeanCPE~full$fishPerKM+full$conductance+full$surfaceArea))#R2 -0.0811, p 0.574
summary(lm(full$lkmeanCPE~full$fishPerKM+full$conductance+full$maxSize))#R2 -0.08326, p 0.5793
summary(lm(full$lkmeanCPE~full$conductance+full$maxDepth))
library(ggplot2)
ggplot(full,aes(x=fishPerKM, y=lkmeanCPE))+
geom_point()+geom_text(aes(label=lakeID), hjust=-0.5, vjust=-1)
summary(lm(full$lkmeanCPE~full$conductance+full$maxDepth+full$fishPerKM))
summary(lm(full$lkmeanCPE~full$surfaceArea+full$fishPerKM))
#Example
x <- "dataset"
typeof(x)
attributes(x)
y <- 1:10
y
typeof(y)
length(y)
z <- as.numeric(y)
z
typeof(z)
vector()# an empty 'logical' default vector
vector("character",length = 5)
#a vector of mode 'charac" with 5 elements
character(5)#same but using constructor
numeric(5)#numeric vector with 5 elements
logivcal(5)#logical vec with 5 elements
logical(5)#logical vec with 5 elements
x <- c(1, 2, 3)
x1 <- c(1L, 2L, 3L)
y <- c(TRUE, TRUE, FALSE, FALSE)
z <- c("Sarah", "Tracy", "Jon")
typeof(z)
length(z)
class(z)
str(z)
z <- c(z, "Annette")
z
z<- c("Greg",z)
z
#Vectors from a seqence of numbers
series <- 1:10
seq(10)
seq(from = 1, to = 10, by = 0.1)
#Missing data
x<- c(0.5, NA, 0.7)
x<- c(0.5, NA, 0.7)
x <- c(TRUE, FALSE, NA)
x <- c("a", NA, "c", "d", "e")
x <- c(1+5i, 2-3i, NA)
x <- c("a", NA, "c", "d", NA)
y <- c("a", "b", "c", "d", "e")
is.na(x)
is.na(y)
anyNA(x)
anyNA(y)
1/0
0/0
xx <- c(1.7, "a")
xx <- c(TRUE, 2)
xx <- c("a", TRUE)
as.numeric("1")
as.character(1:2)
length(1:10)
nchar("Software Carpentry")
m <- matrix(nrow = 2, ncol = 2)
m
dim(m)
class(m)
typeof(m)
typeof(m)
FOURS <- matrix(
c(4, 4, 4, 4),
nrow = 2,
ncol = 2)
x <- list(1, "a", TRUE, 1+4i)
x <- list(1, "a", TRUE, 1+4i)
x
x <- vector("list", length = 5) # empty list
length(x)
x[[1]]
x <- 1:10
x <- as.list(x)
length(x)
xlist <- list(a = "Karthik Ram", b = 1:10, data = head(iris))
xlist
dat <- data.frame(id = letters[1:10], x = 1:10, y = 11:20)
dat
is.list(dat)
class(dat)
dat[1, 3]
dat[["y"]]
dat$y
str(iris)
