for (i in 1:years) N.projections[, i + 1] <- A %*% N.projections[,i]
matplot(0:years, t(N.projections), type = "l", lty = 1:3, col = 1, ylab = "Stage Abundance", xlab = "Year")
legend("topleft", legend = c("Seeds", "Small Adult", "Large Adult"),lty = 1:3, col = 1, bty = "n")
#calculating annual growth
N.totals <- apply(N.projections, 2, sum)
Rs <- N.totals[-1]/N.totals[-(years + 1)]
#plot R for each year(t)
plot(0:(years - 1), Rs, type = "b", xlab = "Year", ylab = "R")
#Eigenanalysis in R
eigs.A <- eigen(A)
eigs.A
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
#Eigenanalysis in R
eigs.A <- eigen(A)
eigs.A
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A["values"])
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
L1 <- Re(eigs.A[["values"]][dom.pos])
L1
#Power iteration method of eigenanalysis, mulitplying projection matrix by stage structure again
t<-20
Nt<- N0/sum(N0)
#for-loop that re-uses Nt for each time step, making empty numeric vector to hold the output.
R.t <- numeric(t)
for (i in 1:t) R.t[i] <- {
Nt1 <- A %*% Nt
R <- sum(Nt1)/sum(Nt)
Nt <- Nt1/sum(Nt1)
R
}
#Comparing results to estimate of lambda
par(mar = c(5, 4, 3, 2))
plot(1:t, R.t, type = "b", main = quote("Convergence Toward " * lambda))
points(t, L1, pch = 19, cex = 1.5)
#calculating stable stage distribution, as N approaches constant rates relative abundance can be found
# SSD = w1/sum of W1 elements
w <- Re(eigs.A[["vectors"]][, dom.pos])
ssd <- w/sum(w)
round(ssd, 3)
#calculating reproductive value
M <- eigen(t(A))
v <- Re(M$vectors[, which.max(Re(M$values))])
RV <- v/v[1]
RV
#calculating sensitivities of matrix
s <- v %*% t(w)
(S <- vw.s/as.numeric(v %*% w))
S <- vw/as.numeric(v %*% w)
S <- v*ws/as.numeric(v %*% w)
N0 <- matrix(c(0,10,10,10,10,10))
A <- matrix(c(0,0,0,0,0,1.642,0.098,0,0,0,0,0.437,0,0.342,
0.591,0.050,0.095,0,0,0.026,0.295,0.774,
0.177,0.194,0,0,0,0.145,0.596,0.362,0,0,0,
0.016,0.277,0.489),nr=6,byrow=T)
years <- 10
N.projections <- matrix(0,nrow=nrow(A), ncol=years+1)
N.projections[,1] <- N0
for (i in 1:years){
N.projections[,i+1] <- A%*%N.projections[,i]
}
matplot(0:years,t(N.projections), type="l", lty=1:10,col=1,
ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("Seedling", "Small 1-leaved Plant",
"Medium 1-leaved Plant", "Large 1-leaved Plant",
"Fertile Plant"),
lty=1:6, col=1, bty="n")
# c)
eigs.A <- eigen(A)
dom.pos <- which.max(eigs.A[["values"]])
w <- Re(eigs.A[["vectors"]][,dom.pos])
ssd <- w/sum(w)
round(ssd,3)
#d) Calculating lambda
L1 <- Re(eigs.A[["values"]][dom.pos])
# e) Calculating elasticities
M <- eigen(t(A))
v <- Re(M$vectors[, which.max(Re(M$values))])
vw.s <- v %*% t(w)
S <- vw.s/as.numeric(v %*% w)
elas <- (A/L1) * S
round(elas,3)
#2.2
M<- matrix(c(0,0,0,0,127,4,80,
0.6747, 0.7370,0,0,0,0,0,
0,0.0486,0.6610,0,0,0,0,
0,0,0.0147,0.6907,0,0,0,
0,0,0,0.0518,0,0,0,
0,0,0,0,0.8091,0,0,
0,0,0,0,0,0.8091,0.8089), nr=7, byrow=T)
M
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
for (i in 1:time){
N.projections[,i+1] <- M%*%N.projections[,i]
}
# working on stable stage distribution
eigs.M <- eigen(M)
dom.pos <- which.max(eigs.M[["values"]])
w <- Re(eigs.M[["vectors"]][,dom.pos])
ssd <- w/sum(w)
round(ssd,4)
#calculate lambda
lambda <- Re(eigs.M[["values"]][dom.pos])
lambda #0.945031
#detmine elasticities
M.new <- eigen(t(M))
v <- Re(M.new$vectors[, which.max(Re(M.new$values))])
vw.s <- v %*% t(w)
S <- vw.s/as.numeric(v %*% w)
elas <- (M/lambda) * S
round(elas,3)
#graph this for 10 years
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("eggs,hatchlines", "small juveniles", "large juveniles", "subadults", "novice breeders", "1st-yr remigrants", "mature breeders"), lty=1:7, col=1, bty="n")
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("eggs,hatchlines", "small juveniles", "large juveniles", "subadults", "novice breeders", "1st-yr remigrants", "mature breeders"), lty=1:7, col=1, bty="n")
#graph this for 10 years
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
#Simple Numerical Evaluation of rd (Fig. 3.5)
#Here we vary rd by creating a short systematic sequence rd = 1.3, 1.6, . . . , 2.8. We set
#t = 50, and use dlogistic to create a trajectory for each of the six rd.
rd.v <- seq(1.3, 2.8, by = 0.3)
t <- 15
Ns <- data.frame(sapply(rd.v, function(r) dlogistic(rd = r, t = t)))
library(primer)
#Writing a Function For Discrete Logistic Growth
#An R function will simplify our explorations. It will return a vector of N, given ,
#rd, N0, and t. The function arguments can have defaults (e.g., t=10).
dlogistic <- function(alpha = 0.01, rd = 1, N0 = 2, t = 15) {
N <- c(N0, numeric(t))
for (i in 1:t) N[i + 1] <- {
N[i] + rd * N[i] * (1 - alpha * N[i])
}
return(N)
}
#Graphing Population Size
#We can use the function created above, dlogistic, with default settings, to generate
#a population projection.
> Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
> t <- 15; a <- 0.01
> plot(0:t, Nts)
> abline(h = 1/a, lty = 3)
#(Per Capita) Population Growth Increment vs. N (Fig. 3.3)
#Using the previous projection, we now capture both the total and the per capita
#growth increment per unit time, from t to t+1. We graph these versus Nt, population
#size at t.
total.incr <- Nts[1:t + 1] - Nts[1:t]
per.capita.incr <- total.incr/Nts[1:t]
Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
t <- 15; a <- 0.01
plot(0:t, Nts)
abline(h = 1/a, lty = 3)
Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
t <- 15; a <- 0.01
plot(0:t, Nts)
abline(h = 1/a, lty = 3)
#(Per Capita) Population Growth Increment vs. N (Fig. 3.3)
#Using the previous projection, we now capture both the total and the per capita
#growth increment per unit time, from t to t+1. We graph these versus Nt, population
#size at t.
total.incr <- Nts[1:t + 1] - Nts[1:t]
per.capita.incr <- total.incr/Nts[1:t]
plot(Nts[1:t], total.incr)
plot(Nts[1:t], per.capita.incr)
#Numerical Evaluation of Initial Conditions (Fig. 3.4a)
#Here we draw randomly 30 N0 from a uniform distribution between zero and 1.2K.
#We also include zero specifically. We then use sapply to run dlogistic for each N0,
#using defaults for the other arguments.
N0s <- c(0, runif(30) * 1.1 * 1/a)
N <- sapply(N0s, function(n) dlogistic(N0 = n))
matplot(0:t, N, type = "l", lty = 1, lwd = 0.75, col = 1)
text(t, 1/a, expression(italic("K") == 1/alpha), adj = c(1,0))
#Numerical Evaluation of  (Fig. 3.4b)
#Here we draw 30 random K from a uniform distribution from 50 to 1000, and convert
#these to . We use sapply to run dlogistic for each .
a.s <- 1/runif(30, min = 50, max = 1000)
#Numerical Evaluation of  (Fig. 3.4b)
#Here we draw 30 random K from a uniform distribution from 50 to 1000, and convert
#these to. We use sapply to run dlogistic for each .
a.s <- 1/runif(30, min = 50, max = 1000)
N <- sapply(a.s, function(a) dlogistic(alpha = a, t = 15))
#We next plot all populations, and use some fancy code to add some informative text
#in the right locations.
matplot(0:t, N, type = "l", ylim = c(0, 1000), lty = 1, lwd = 0.75,col = 1)
text(8, 1/min(a.s), bquote(italic(alpha) == .(round(min(a.s),3))), adj = c(1, 0.5))
text(10, 1/max(a.s), bquote(italic(alpha) == .(round(max(a.s),3))), adj = c(0, 1.2))
#Simple Numerical Evaluation of rd (Fig. 3.5)
#Here we vary rd by creating a short systematic sequence rd = 1.3, 1.6, . . . , 2.8. We set
#t = 50, and use dlogistic to create a trajectory for each of the six rd.
rd.v <- seq(1.3, 2.8, by = 0.3)
t <- 15
Ns <- data.frame(sapply(rd.v, function(r) dlogistic(rd = r, t = t)))
matplot(0:t, Ns, type = "l", col = 1)
library(primer)
#Writing a Function For Discrete Logistic Growth
#An R function will simplify our explorations. It will return a vector of N, given ,
#rd, N0, and t. The function arguments can have defaults (e.g., t=10).
dlogistic <- function(alpha = 0.01, rd = 1, N0 = 2, t = 15) {
N <- c(N0, numeric(t))
for (i in 1:t) N[i + 1] <- {
N[i] + rd * N[i] * (1 - alpha * N[i])
}
return(N)
}
#Graphing Population Size
#We can use the function created above, dlogistic, with default settings, to generate
#a population projection.
Nts <- dlogistic()
#Now we plot the projection, and put in a dotted line for 1/ or K.
t <- 15; a <- 0.01
plot(0:t, Nts)
abline(h = 1/a, lty = 3)
#(Per Capita) Population Growth Increment vs. N (Fig. 3.3)
#Using the previous projection, we now capture both the total and the per capita
#growth increment per unit time, from t to t+1. We graph these versus Nt, population
#size at t.
total.incr <- Nts[1:t + 1] - Nts[1:t]
per.capita.incr <- total.incr/Nts[1:t]
plot(Nts[1:t], total.incr)
plot(Nts[1:t], per.capita.incr)
#Chapter 3 problem
#3.1
#rd of an annual plant that has a maximum growth rate of Nt+1/Nt=2 at very, very small population sizes
rd <- 0
t <- 15
Ns <- data.frame(sapply(rd.v, function(r) dlogistic(rd = r, t = t)))
matplot(0:t, Ns, type = "l", col = 1)
#Chapter 3 problem
#3.1
#a) rd of an annual plant that has a maximum growth rate of Nt+1/Nt=2 at very, very small population sizes
rd = 1
#b)calculate alpha
alpha = 1/100
#c)calculate logisitc growth equation
dlogistic <- function(alpha,rd,N0,t) {
N = c(N0, numeric(t))
for(i in 1:t) {
N[i+1] = N[i] + rd * N[i] * (1 - alpha * N[i])
}
return(N)
}
#d) graph for 10 years
dlogis = dlogistic(alpha, rd, 1, 10)
plot(0:10,dlogis)
plot(ylab="years", y = 0:10,dlogis)
plot(xlab="years", x = 0:10,dlogis)
plot(xlab="years",ylab = "growth" x = 0:10,dlogis)
plot(xlab="years",ylab = "growth", x = 0:10,dlogis)
clogistic <- function(times, y, parms) {
n = y[1]
r = parms[1]
alpha = parms[2]
dN.dt = r*n*(1-alpha*n)
return(list(c(dN.dt)))
}
prms = c(r = r, alpha = alpha)
init.N = c(1000)
t.s = seq(0.1,50, by = 1)
out = ode(y = init.N, times = t.s, clogistic, parms = prms)
plot(out[, 1], out[, 2], type = "l", xlab = "Time", ylab = "N")
clogistic <- function(times, y, parms) {
n = y[1]
r = parms[1]
alpha = parms[2]
dN.dt = r*n*(1-alpha*n)
return(list(c(dN.dt)))
}
prms = c(r = r, alpha = alpha)
n = y[1]
r = parms[1]
alpha = parms[2]
dN.dt = r*n*(1-alpha*n)
library(primer)
thetalogistic <- function(times, y, parms) {
n = y[1]
with(as.list(parms), {
dN.dt = r * n * (1 - (alpha * n)^theta)
return(list(c(dN.dt)))
})
}
#b)show that theta=1
prms = c(r = r, alpha = alpha)
r <- 0.75
alpha <- 0.01
theta <- c(0.5, 1, 2)
N <- 0:110
theta.out <- sapply(theta, function(th) {
1 - (alpha * N)^th
})
matplot(N, theta.out, type = "l", col = 1)
abline(h = 0)
legend("topright", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
matplot(N, theta.out, ylab="theta",type = "l", col = 1)
abline(h = 0)
legend("topright", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
legend("bottomleft", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
r <- 0.75
alpha <- 0.01
theta <- c(0.5, 1, 2)
N <- 0:110
theta.out <- sapply(theta, function(th) {
1 - (alpha * N)^th
})
matplot(N, theta.out, ylab="theta",type = "l", col = 1)
abline(h = 0)
legend("bottomleft", legend = paste("theta =", c(2, 1, 0.5)), lty = 3:1)
#3.5
#discrete version of the logistic growth model
Kstart = 100
time = 1:20
K = numeric(20)
for(i in 1:20) {
K[i] = Kstart + rnorm(1, m=0, sd=5)
}
plot(time, K)
dlogistic <- function(K,rd,N0,t) {
N = c(N0, numeric(t))
for(i in 1:t) {
N[i+1] = N[i] + rd * N[i] * (1 - (1/K[i]) * N[i])
}
return(N)
}
d = dlogistic(K, rd, 1, 20)
plot(0:20,d)
plot(ylab="growth", xlab="years",0:20,d)
#b)
rd = 1
Nsim = 100
N_mean = numeric(Nsim)
S_D = numeric(Nsim)
for (j in 1:Nsim){
stdev = sample(seq(0.1,15,0.5),1)
S_D[j] = stdev
Kstart = 100
time = 1:20
K = numeric(20)
for(i in 1:20) {
K[i] = Kstart + rnorm(1, m=0, sd=stdev)
}
N_mean[j] = mean(dlogistic(K, rd, 1, 20))
}
plot(S_D, N_mean)
plot(xlab="standard deviation",ylab="Mean",S_D, N_mean)
#discrete time model
dlvcomp2 <- function(N, alpha, rd = c(1, 1)) {
N1.t1 <- N[1] + rd[1] * N[1] * (1 - alpha[1, 1] * N[1] - alpha[1, 2] * N[2])
N2.t1 <- N[2] + rd[2] * N[2] * (1 - alpha[2, 1] * N[1] - alpha[2, 2] * N[2])
c(N1.t1, N2.t1)
}
#Create matrix of aplhas
aplhs <- matrix(c(0.01, 0.005, 0.008, 0.01), ncol = 2, byrow = T)
#Create matrix of aplhas
aplhs <- matrix(c(0.01, 0.005, 0.008, 0.01), ncol = 2, byrow = TRUE)
View(aplhs)
t<- 20
#make matrix for results, add initial population sizes to project future
N <- matrix(NA, nrow = t + 1, ncol = 2)
N[1, ] <- c(10, 10)
for (i in 1:t) N[i + 1, ] <- dlvcomp2(N[i, ], alphs)
#Create matrix of aplhas, make time vector
aplhs <- matrix(c(0.01, 0.005, 0.008, 0.01), ncol = 2, byrow = TRUE)
#Create matrix of aplhas, make time vector
alphs <- matrix(c(0.01, 0.005, 0.008, 0.01), ncol = 2, byrow = TRUE)
t<- 20
#make matrix for results, add initial population sizes to project future
N <- matrix(NA, nrow = t + 1, ncol = 2)
N[1, ] <- c(10, 10)
for (i in 1:t) N[i + 1, ] <- dlvcomp2(N[i, ], alphs)
#plot projections
matplot(0:t, N, type = "l", col = 1, ylim = c(0, 110))
abline(h = 1/alphs[1, 1], lty = 3)
text(0, 1/alphs[1, 1], "K", adj = c(0, 0))
legend("right", c(expression("Sp.1 " * (alpha[21] == 0.008)), expression("Sp.2 " * (alpha[12] == 0.005))),
lty = 1:2, bty = "n")
lvcomp2 <- function(t, n, parms) {
with(as.list(parms), {
dn1dt <- r1 * n[1] * (1 - a11 * n[1] - a12 * n[2])
dn2dt <- r2 * n[2] * (1 - a22 * n[2] - a21 * n[1])
list(c(dn1dt, dn2dt))
})
}
library(primer)
library(deSolve)
parms <- c(r1 = 1, r2 = 0.1, a11 = 0.2, a21 = 0.1, a22 = 0.02,
+ a12 = 0.01)
initialN <- c(2, 1)
parms <- c(r1 = 1, r2 = 0.1, a11 = 0.2, a21 = 0.1, a22 = 0.02, a12 = 0.01)
initialN <- c(2, 1)
out <- ode(y = initialN, times = 1:100, func = lvcomp2, parms = parms)
matplot(out[, 1], out[, -1], type = "l")
#martix to hold alphas
a <- matrix(c(0.01, 0.005, 0.005, 0.01), ncol = 2, byrow = TRUE)
N2iso <- expression(1/a[2, 2] - (a[2, 1]/a[2, 2]) * N1)
N1<- 0:200
#plot
plot(N1, eval(N2iso), type = "l", ylim = c(0, 200), xlim = c(0, 200), ylab = expression("N"[2]))
arrows(x0 = 90, y0 = 150, x1 = 90, y1 = 80, length = 0.1)
arrows(x0 = 75, y0 = 0, x1 = 75, y1 = 50, length = 0.1)
library(primer)
#discrete time model, uses N,alpha, rd - growth factor, 2 populations N1 and N2
dlvcomp2 <- function(N, alpha, rd = c(1, 1)) {
N1.t1 <- N[1] + rd[1] * N[1] * (1 - alpha[1, 1] * N[1] - alpha[1, 2] * N[2])
N2.t1 <- N[2] + rd[2] * N[2] * (1 - alpha[2, 1] * N[1] - alpha[2, 2] * N[2])
c(N1.t1, N2.t1)
}
#Create matrix of aplhas, make time vector
alphs <- matrix(c(0.01, 0.005, 0.008, 0.01), ncol = 2, byrow = TRUE)
t<- 20
#make matrix for results, add initial population sizes to project future
N <- matrix(NA, nrow = t + 1, ncol = 2)
N[1, ] <- c(10, 10)
for (i in 1:t) N[i + 1, ] <- dlvcomp2(N[i, ], alphs)
#plot projections
matplot(0:t, N, type = "l", col = 1, ylim = c(0, 110))
abline(h = 1/alphs[1, 1], lty = 3)
text(0, 1/alphs[1, 1], "K", adj = c(0, 0))
legend("right", c(expression("Sp.1 " * (alpha[21] == 0.008)), expression("Sp.2 " * (alpha[12] == 0.005))),
lty = 1:2, bty = "n")
#martix to hold alphas, function to plot N2 isocline
a <- matrix(c(0.1, 0.05, 0.01, 0.1), ncol = 2, byrow = TRUE)
N2iso <- expression(1/a[2, 2] - (a[2, 1]/a[2, 2]) * N1)
N1<- 0:200
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylim = c(0, 200), xlim = c(0, 200), ylab = expression("N"[2]))
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 90, y0 = 150, x1 = 90, y1 = 80, length = 0.1)
arrows(x0 = 75, y0 = 0, x1 = 75, y1 = 50, length = 0.1)
arrows(x0 = 90, y0 = 150, x1 = 90, y1 = 80, length = 0.1)
arrows(x0 = 75, y0 = 0, x1 = 75, y1 = 50, length = 0.1)
arrows(x0 = 200, y0 = 10, x1 = 90, y1 = 80, length = 0.1)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 100, y0 = 150, x1 = 50, y1 = 80, length = 0.1)
arrows(x0 = 100, y0 = 0, x1 = 50, y1 = 5, length = 0.1)
arrows(x0 = 100, y0 = 10, x1 = 50, y1 = 5, length = 0.1)
arrows(x0 = 100, y0 = 15, x1 = 50, y1 = 5, length = 0.1)
arrows(x0 = 100, y0 = 15, x1 = 150, y1 = 5, length = 0.1)
arrows(x0 = 100, y0 = 10, x1 = 150, y1 = 5, length = 0.1)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 999, y0 = 0, x1 = 150, y1 = 10, length = 0.1)
arrows(x0 = 100, y0 = 0, x1 = 150, y1 = 10, length = 0.1)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 101, y0 = 0, x1 = 150, y1 = 10, length = 0.1, angle = 45)
arrows(x0 = 101, y0 = 0, x1 = 150, y1 = 10, length = 0.1, angle = 90)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 150, y0 = 0, x1 = 101, y1 = 10, length = 0.1)
arrows(x0 = 100, y0 = 0, x1 = 150, y1 = 10, length = 0.1)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 100, y0 = 0, x1 = 150, y1 = 10, length = 0.1)
arrows(x0 = 100, y0 = 0, x1 = 150, y1 = 10, length = 0.1, angle = 180)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 100, y0 = 0, x1 = 150, y1 = 10, length = 0.1, angle = 90)
arrows(x0 = 100, y0 = 0, x1 = 150, y1 = 10, length = 0.1)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 100, y0 = 10, x1 = 150, y1 = 5, length = 0.1)
arrows(x0 = 100, y0 = 10, x1 = 100, y1 = 5, length = 0.1)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 100, y0 = 10, x1 = 100, y1 = 5, length = 0.1)
arrows(x0 = 50, y0 = -5, x1 = 50, y1 = 0, length = 0.1)
arrows(x0 = 150, y0 = 10, x1 = 150, y1 = 5, length = 0.1)
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
arrows(x0 = 150, y0 = 10, x1 = 150, y1 = 5, length = 0.1)
arrows(x0 = 50, y0 = -5, x1 = 50, y1 = 0, length = 0.1)
#finding equlibria using eigenvalues, set expresssions for the equlibira
N1Star <- expression((a22 - a12)/(a22 * a11 - a12 * a21))
#martix to hold alphas, function to plot N2 isocline
a <- matrix(c(0.1, 0.1, 0.1, 0.1), ncol = 2, byrow = TRUE)
N2iso <- expression(1/a[2, 2] - (a[2, 1]/a[2, 2]) * N1)
N1<- 0:200
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
#martix to hold alphas, function to plot N2 isocline
a <- matrix(c(0.1, 0.1, 0.1, 0.1), ncol = 2, byrow = TRUE)
N2iso <- expression(1/a[2, 2] - (a[2, 1]/a[2, 2]) * N1)
N1<- 0:200
#plot, add arrows to see what happens to N2 when its above and below the isocline value
plot(N1, eval(N2iso), type = "l", ylab = expression("N"[2]))
setwd("C:/Users/Camille/Desktop/Fishscapes/hsSurvey")
# load function to load data from google drive
source("gdriveURL.R")
library(dplyr)
######## angling CPUE
# load creel data from google drive
creel1=gdriveURL("https://drive.google.com/open?id=1lxUd742QZMXDQunyFBnENKMYZ1XNM_Pc")
creel2=gdriveURL("https://drive.google.com/open?id=1UYhbGH28WXjmi-4BzhfwO4KYwrBCNO2Q")
