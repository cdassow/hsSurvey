count2=count-11
}
print(c("There are this many values below 10 in x:",count))
print(c("There are this many values above 10 in x:",count2))
#4
#4
#4
x=1:10
y=5:15
plot(x,y, type="p")
#5
x=1:10
x <- 1:10
#5
x <- 1:10
y=5:15
plot(x,y, type="p")
#5
x <- 1:10
y=5:15
plot(x,y, type="p")
#5
x <- 1:10
#5
x <- 1:10
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
SSgr <- SS6$Count[2:(t + 1)]/SS6$Count[1:t]
lam.A <- sum(SSgr)/t
#Comparing arithmetic and geometric averages (Fig. 1.5)
#First we select the number of observed R (t = 5); this will require that we use six
#years of Song Sparrow data.
t <- 5
SS6 <- sparrows[1:(t + 1), ]
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
SSgr <- SS6$Count[2:(t + 1)]/SS6$Count[1:t]
lam.A <- sum(SSgr)/t
lam.G <- prod(SSgr)^(1/t)
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
SSgr <- SS6$Count[2:(t + 1)]/SS6$Count[1:t]
t <- 5
SS6 <- sparrows[1:(t + 1), ]
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
SSgr <- SS6$Count[2:(t + 1)]/SS6$Count[1:t]
lam.A <- sum(SSgr)/t
lam.G <- prod(SSgr)^(1/t)
#Now we can plot the data, and the projections based on the two averages (Fig. 1.5).
N0 <- SS6$Count[1]
plot(0:t, SS6$Count, ylab = "Projected Population Size")
lines(0:t, N0 * lam.A^(0:t), lty = 2)
lines(0:t, N0 * lam.G^(0:t), lty = 1)
legend(0, 70, c("Arithmetic Ave.", "Geometric Ave."),
+ title = "Projections Based On:",
+ lty = 2:1, bty = "n", xjust = 0)
SS6 <- sparrows[1:(t + 1), ]
#Numerical approximation of e
#Here we use brute force to try to get an approximate solution to eq. 1.9.We’ll let n be
#the number of divisions within one year. This implies that the finite rate of increase
#during each of these fractional time steps is rd/n. Let the lambda = 2 and therefore rd = 1.
#Note that because N0 = 1, we could ignore it, but let’s keep it in for completeness.
n <- 0:100
N0 <- 1
rd <- 1
N1 <- N0 * (1 + rd/n)^n
#Last, we plot the ratio and add some fancy math text to the plot (see ?plotmath for
details on mathematical typesetting in R).
plot(n, N1/N0, type = "l")
text(50, 2, "For n = 100,")
text(50, 1.6, bquote((1 + frac("r"["d"], "n"))^"n" ==
+ .(round(N1[101]/N0, 3))))
#projecting a continuous population
r <- c(-0.03, -0.02, 0, 0.02, 0.03)
N0 <- 2; t <- 1:100
cont.mat <- sapply(r, function(ri) N0 * exp(ri * t))
#Next we create side-by-side plots, using both arithmetic and logarithmic scales, and
#add a legend.
layout(matrix(1:2, nrow = 1))
matplot(t, cont.mat, type = "l", ylab = "N", col = 1)
legend("topleft", paste(rev(r)), lty = 5:1, col = 1, bty = "n",
+ title = "r")
matplot(t, cont.mat, type = "l", ylab = "N", log = "y", col = 1)
m.time <- function(r, m = 2) {
+ log(m)/r
+ }
#creating a function for doubling time
m.time <- function(r, m = 2) {log(m)/r}
#Now we create a vector of r, and then use m.time to generate a vector of doublingtimes.
rs <- c(0, 1, 2)
m.time(rs)
matplot(t, cont.mat, type = "l", ylab = "N", log = "y", col = 1)
#Chapter 1 problems:
#1
N <- c(150,100,125,200,225,150,100,175,100,150)
year <- 1996:2005
plot(year, N)
plot(year, N)
rates = N[2:10]/N[1:9]
rates
#[1] 0.6666667 1.2500000 1.6000000 1.1250000 0.6666667 0.6666667 1.7500000 0.5714286 1.5000000
plot(year,rates)
#A Primer in Ecology in R Notes
#Chapter 1: pdf (p.1-40)
#Simple Graphing of Population Size (Fig. 1.3)Here we create two vectors:
#population size (N), and years. Using c() allows us to
#create an arbitrary vector, and the colon, :, provides a sequence of consecutive integers.
N <- c(1, 3, 9, 27, 81)
year <- 2001:2005
#Here we divide each element of one vector (the second through fifth element of N)
#by each element of another vector (the first through fourth elements of N).
rates = N[2:5]/N[1:4]
rates
#Chapter 1 problems:
#1
N <- c(150,100,125,200,225,150,100,175,100,150)
year <- 1996:2005
plot(year, N)
rates = N[2:10]/N[1:9]
rates
#[1] 0.6666667 1.2500000 1.6000000 1.1250000 0.6666667 0.6666667 1.7500000 0.5714286 1.5000000
plot(year[2:10],rates)
plot(year,rates)
N0 <- year[1]
N0 <- 1996
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
Popgr <- PopCount[2:(t + 1)]/PopCount[1:t]
PopCount <- N[1:(t + 1), ]
data.frame(x=year,y=N)
Pop<-data.frame(x=year,y=N)
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
Popgr <- Pop[2:(year + 1)]/Pop[1:year]
#Next we calculate ! for each generation, from t to t + 1, and calculate the arithmetic
#and geometric means.
Popgr <- Pop[2:(t + 1)]/Pop[1:t]
#2
m.time <- function(r, m = 2) {log(m)/r}
#Now we create a vector of r, and then use m.time to generate a vector of doublingtimes.
rs <- c(0, 1, 2)
m.time(rs)
triple.time <- function(r, m = 3) {log(m)/r}
triple.time(rs)
#3
#intrinsic rate of increase 630 million in 1700, 6.3 billion
N <- c(6300000,63000000000)
year <- (1700,2003)
install.packages("primer")
#Chapter 1 problems:
#1
N <- c(150,100,125,200,225,150,100,175,100,150)
year <- 1996:2005
plot(year, N)
rates = N[2:10]/N[1:9]
rates
#[1] 0.6666667 1.2500000 1.6000000 1.1250000 0.6666667 0.6666667 1.7500000 0.5714286 1.5000000
plot(year[2:10],rates)
avgrate <- sum(rates/9)
#Comparing arithmetic and geometric averages (Fig. 1.5)
#First we select the number of observed R (t = 5); this will require that we use six
#years of Song Sparrow data.
t <- 5
SS6 <- sparrows[1:(t + 1), ]
head(sparrows)
read.csv(sparrows)
load(sparrows)
#A Primer in Ecology in R Notes
#Chapter 1: pdf (p.1-40)
library(primer)
#Comparing arithmetic and geometric averages (Fig. 1.5)
#First we select the number of observed R (t = 5); this will require that we use six
#years of Song Sparrow data.
t <- 5
SS6 <- sparrows[1:(t + 1), ]
install.packages(PET)
PopSim <- function(Rs, N0, years = 50, sims = 10) {
sim.RM = matrix(sample(Rs, size = sims * years, replace = TRUE),
nrow = years, ncol = sims)
output <- numeric(years + 1)
output[1] <- N0
outmat <- sapply(1:sims, function(i) {
for (t in 1:years) output[t + 1] <- round(output[t] * sim.RM[t, i], 0)
output
})
return(outmat)
}
system.time(output <- PopSim(Rs = obs.R, N0 = 43, sims = 1000))
output <- PopSim(Rs = obs.R, N0 = 43, sims = 1000)
PopSim <- function(Rs, N0, years = 50, sims = 10) {
sim.RM = matrix(sample(Rs, size = sims * years, replace = TRUE),
nrow = years, ncol = sims)
output <- numeric(years + 1)
output[1] <- N0
outmat <- sapply(1:sims, function(i) {
for (t in 1:years) output[t + 1] <- round(output[t] * sim.RM[t, i], 0)
output
})
return(outmat)
}
projection <- 150*[(1.08)^30]
projection <- 150*(1.08)^30
projection <- 150*(1.08)^20
#1B
R=N[-1]/N[-length(N)]
plot(years[-length(years)],R,type='p')
Rbar.A=mean(R)
Rba.G=prod(R)^(1/length(R))
projection <- 150*Rbar.A^20
projection <- 150*Rbar.A^30
#A primer of Ecology in R
#Chapter2 Density independent demography
#Matrices in R
M <- matrix(1:4, nr = 2, byrow = T)
M
N <- matrix(c(10, 20, 30, 40), nr = 2)
N
M %*% N
A <- matrix(c(0, 0.5, 20, 0.3, 0, 0, 0, 0.5, 0.9), nr = 3, byrow = TRUE)
N0 <- matrix(c(100, 250, 50), ncol = 1)
N1 <- A %*% N0
N1
#project population over six years using a for loop,each year depends on the previous year
years <- 6
N.projections <- matrix(0, nrow = nrow(A), ncol = years + 1)
N.projections[, 1] <- N0
for (i in 1:years) N.projections[, i + 1] <- A %*% N.projections[,i]
matplot(0:years, t(N.projections), type = "l", lty = 1:3, col = 1, ylab = "Stage Abundance", xlab = "Year")
legend("topleft", legend = c("Seeds", "Small Adult", "Large Adult"),lty = 1:3, col = 1, bty = "n")
#calculating annual growth
N.totals <- apply(N.projections, 2, sum)
Rs <- N.totals[-1]/N.totals[-(years + 1)]
#plot R for each year(t)
plot(0:(years - 1), Rs, type = "b", xlab = "Year", ylab = "R")
#Eigenanalysis in R
eigs.A <- eigen(A)
eigs.A
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
#Eigenanalysis in R
eigs.A <- eigen(A)
eigs.A
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A["values"])
#note first dominant eigenvalue is lambda, fit ut using max to find greatest value =lamb
dom.pos <- which.max(eigs.A[["values"]])
L1 <- Re(eigs.A[["values"]][dom.pos])
L1
#Power iteration method of eigenanalysis, mulitplying projection matrix by stage structure again
t<-20
Nt<- N0/sum(N0)
#for-loop that re-uses Nt for each time step, making empty numeric vector to hold the output.
R.t <- numeric(t)
for (i in 1:t) R.t[i] <- {
Nt1 <- A %*% Nt
R <- sum(Nt1)/sum(Nt)
Nt <- Nt1/sum(Nt1)
R
}
#Comparing results to estimate of lambda
par(mar = c(5, 4, 3, 2))
plot(1:t, R.t, type = "b", main = quote("Convergence Toward " * lambda))
points(t, L1, pch = 19, cex = 1.5)
#calculating stable stage distribution, as N approaches constant rates relative abundance can be found
# SSD = w1/sum of W1 elements
w <- Re(eigs.A[["vectors"]][, dom.pos])
ssd <- w/sum(w)
round(ssd, 3)
#calculating reproductive value
M <- eigen(t(A))
v <- Re(M$vectors[, which.max(Re(M$values))])
RV <- v/v[1]
RV
#calculating sensitivities of matrix
s <- v %*% t(w)
(S <- vw.s/as.numeric(v %*% w))
S <- vw/as.numeric(v %*% w)
S <- v*ws/as.numeric(v %*% w)
N0 <- matrix(c(0,10,10,10,10,10))
A <- matrix(c(0,0,0,0,0,1.642,0.098,0,0,0,0,0.437,0,0.342,
0.591,0.050,0.095,0,0,0.026,0.295,0.774,
0.177,0.194,0,0,0,0.145,0.596,0.362,0,0,0,
0.016,0.277,0.489),nr=6,byrow=T)
years <- 10
N.projections <- matrix(0,nrow=nrow(A), ncol=years+1)
N.projections[,1] <- N0
for (i in 1:years){
N.projections[,i+1] <- A%*%N.projections[,i]
}
matplot(0:years,t(N.projections), type="l", lty=1:10,col=1,
ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("Seedling", "Small 1-leaved Plant",
"Medium 1-leaved Plant", "Large 1-leaved Plant",
"Fertile Plant"),
lty=1:6, col=1, bty="n")
# c)
eigs.A <- eigen(A)
dom.pos <- which.max(eigs.A[["values"]])
w <- Re(eigs.A[["vectors"]][,dom.pos])
ssd <- w/sum(w)
round(ssd,3)
#d) Calculating lambda
L1 <- Re(eigs.A[["values"]][dom.pos])
# e) Calculating elasticities
M <- eigen(t(A))
v <- Re(M$vectors[, which.max(Re(M$values))])
vw.s <- v %*% t(w)
S <- vw.s/as.numeric(v %*% w)
elas <- (A/L1) * S
round(elas,3)
#2.2
M<- matrix(c(0,0,0,0,127,4,80,
0.6747, 0.7370,0,0,0,0,0,
0,0.0486,0.6610,0,0,0,0,
0,0,0.0147,0.6907,0,0,0,
0,0,0,0.0518,0,0,0,
0,0,0,0,0.8091,0,0,
0,0,0,0,0,0.8091,0.8089), nr=7, byrow=T)
M
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
for (i in 1:time){
N.projections[,i+1] <- M%*%N.projections[,i]
}
# working on stable stage distribution
eigs.M <- eigen(M)
dom.pos <- which.max(eigs.M[["values"]])
w <- Re(eigs.M[["vectors"]][,dom.pos])
ssd <- w/sum(w)
round(ssd,4)
#calculate lambda
lambda <- Re(eigs.M[["values"]][dom.pos])
lambda #0.945031
#detmine elasticities
M.new <- eigen(t(M))
v <- Re(M.new$vectors[, which.max(Re(M.new$values))])
vw.s <- v %*% t(w)
S <- vw.s/as.numeric(v %*% w)
elas <- (M/lambda) * S
round(elas,3)
#graph this for 10 years
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("eggs,hatchlines", "small juveniles", "large juveniles", "subadults", "novice breeders", "1st-yr remigrants", "mature breeders"), lty=1:7, col=1, bty="n")
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
legend("topleft", legend=c("eggs,hatchlines", "small juveniles", "large juveniles", "subadults", "novice breeders", "1st-yr remigrants", "mature breeders"), lty=1:7, col=1, bty="n")
#graph this for 10 years
N0 <- matrix(c(0,10,10,10,10,10,10))
time <-100
N.projections <- matrix(0,nrow=nrow(M), ncol=time+1)
N.projections[,1] <- N0
matplot(0:time,t(N.projections), type="l", lty=1:10,col=1, ylab="Stage Abundance", xlab="Year")
setwd("C:/Users/Camille/Desktop/Fishscapes/hsSurvey")
#clear global evnironment
rm(list=ls())
#load any packages we'll need
library(dplyr)
library(ggplot2)
#go to hsSurvey folder
setwd("C:/Users/Camille/Desktop/Fishscapes/hsSurvey/")
gdriveURL <- function(x){
x =
upURL = sub("^[^=]*", "", x)
y1 =  "https://docs.google.com/uc?id"
y2 = "&export=download"
downURL = paste0(y1,upURL,y2)
read.csv(downURL, header = TRUE)
}
#get walleye pe data from dnr and load data
walldnr<-gdriveURL("https://drive.google.com/open?id=1DPRROWv6Cf_fP6Z-kE9ZgUfdf_F_jSNT")
#get creel interview data and load
creelindata<-gdriveURL("https://drive.google.com/open?id=1pyCKCcAQZiNZz-tX5U2QnZUc79OQEWX2")
#get lake info data
walylinfo<-gdriveURL("https://drive.google.com/open?id=1RiiiT4nmAkWyYIr7VmPk3iPCtTKlGHli")
#find CPUE catch/effort
#sorting for walleye species by code,
creeldatawall<-creelindata[creelindata$speciesCode=="X22",]
creelwall<-creeldatawall[,c(1:3,6,12,18,26,25,30,35)]
View(creelwall)
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
}
BoatCPUE(creelwall)
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
return(CPUE)
}
BoatCPUE(creelwall)
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
return(CPUE)
data.frame(CPUE)
}
BoatCPUE(creelwall)
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
return(CPUE)
data.frame()
}
BoatCPUE(creelwall)
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
return(data.frame())
}
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
return(data.frame())
}
BoatCPUE(creelwall)
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
return(CPUE)
}
BoatCPUE(creelwall)
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
return(CPUE)
data.frame(CPUE)
}
BoatCPUE(creelwall)
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
print(CPUE)
}
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <- x[,7]-x[,8]
num <- time - x[,9]
CPUE <- num*x[,6]/x[10]
print(CPUE)
}
BoatCPUE(creelwall)
View(creelwall)
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <-x[,7]-x[,8]
num <-time - x[,9]
CPUE <-num*x[,6]/x[10]
}
BoatCPUE(creelwall)
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <-x[,7]-x[,8]
num <-time - x[,9]
CPUE <-num*x[,6]/x[10]
return(CPUE)
}
BoatCPUE(creelwall)
#equation for whole boat CPUE [[time(end-start)-notfish]x number of anglers]/catch
#creating loop to calculate CPUEs for each row
BoatCPUE <- function(x){
for(i in 1:nrow(x))
time <-x[,7]-x[,8]
num <-time - x[,9]
CPUE <-num*x[,6]/x[10]
mutate(x, CPUE = CPUE)
}
BoatCPUE(creelwall)
View(creelwall)
View(creelwall)
View(creelwall)
View(creelwall)
